#include "../1-call-site-sensitive/analysis.logic"
#include "../../addons/cfg-analysis/rules.logic"
#include "callgraph_deps.logic"


#ifdef CALLGRAPH_DEPS



/* A single callgraph edge */
CallGraphMethodEdge(?toMethod, ?fromMethod) <-
    Instruction:Method(?invokeInsn, ?fromMethod),
    CallGraphEdge(_, ?invokeInsn, _, ?toMethod).

/* Transitive callgraph base */
CallGraphMethodTransitive(?fromMethod, ?toMethod) <-
    CallGraphMethodEdge(?toMethod, ?fromMethod).

/* Transitive callgraph step */
CallGraphMethodTransitive(?fromMethod, ?toMethod) <-
    CallGraphMethodTransitive(?fromMethod, ?inter),
    CallGraphMethodEdge(?toMethod, ?inter).

/* Data dependency between methods due to a static field store-load */
StaticFieldMethodDataDep(?method, ?dependsOn) <-
    LoadStaticField(?field, _, ?method),
    StoreStaticField(_, ?field, ?dependsOn),
    ?method != ?dependsOn.

/* Data dependency between methods due to a static field store-load */
InstanceFieldMethodDataDep(?method, ?dependsOn) <-
    LoadHeapInstanceField(_, ?loadVar, ?field, _, ?heap),
    Var:DeclaringMethod(?loadVar, ?method),
    StoreHeapInstanceField(?field, _, ?heap, _, ?storeVar),
    Var:DeclaringMethod(?storeVar, ?dependsOn),
    ?method != ?dependsOn.

/* Data dependency between methods due to an array store-load */
HeapArrayMethodDataDep(?method, ?dependsOn) <-
    LoadHeapArrayIndex(_, ?loadVar, _, ?heap),
    Var:DeclaringMethod(?loadVar, ?method),
    StoreHeapArrayIndex(_, ?heap, _, ?storeVar),
    Var:DeclaringMethod(?storeVar, ?dependsOn),
    ?method != ?dependsOn.


/* Any of the above data dependencies */
MethodHeapDataDep(?method, ?dependsOn) <- StaticFieldMethodDataDep(?method, ?dependsOn).

MethodHeapDataDep(?method, ?dependsOn) <- InstanceFieldMethodDataDep(?method, ?dependsOn).

MethodHeapDataDep(?method, ?dependsOn) <- HeapArrayMethodDataDep(?method, ?dependsOn).


/* Method depndency either due to the transitive call graph or the above data dependencies */
MethodDependency(?toMethod, ?fromMethod) <- CallGraphMethodTransitive(?fromMethod, ?toMethod).

MethodDependency(?method, ?dependsOn) <- MethodHeapDataDep(?method, ?dependsOn).


/* The method containing the initial instruction - used to find methods that can be transitively called */
InterestingInitMethod(?initMeth) <-
    InterestingInstructionInit(?insn),
    Instruction:Method[?insn] = ?initMeth.


/* Initial interesting instruction */
InterestingViaCG(?insn) <-
    InterestingInstructionInit(?insn).

/* Any instruction that is intra-procedurally dependent on another interesting instruction */
InterestingViaCG(?insn) <-
    InterestingViaCG(?interesting),
    IntraProceduralDependencyOpt(?insn, ?interesting).

/**
 * Call graph dependence - mark all instructions using the params
 * of methods that can be reached through the call graph
 */
InterestingViaCG(?insn) <-
    InterestingInitMethod(?initMeth),
    MethodDependency(?meth, ?initMeth),
    FormalParam[_, ?meth] = ?formalParam,
    InstructionUsesVar(?insn, ?formalParam).

/* Field store-load inter-procedural data dependency */
InterestingViaCG(?insn) <-
    InterestingViaCG(?interesting),
    StoreFldTo(?var1, ?fld, ?interesting),
    LoadFldFrom(?insn, ?var2, ?fld),
    VarPointsTo(_, ?heap, _, ?var1),
    VarPointsTo(_, ?heap, _, ?var2).

/* Field store-load inter-procedural data dependency */
InterestingViaCG(?insn) <-
    InterestingViaCG(?interesting),
    StoreArrayIndex:Base[?interesting] = ?var1,
    LoadArrayIndex:Base[?insn] = ?var2,
    VarPointsTo(_, ?heap, _, ?var1),
    VarPointsTo(_, ?heap, _, ?var2).



#else

/* Made for optimizing InterestingLoad */
InterestingStoreHeapFld(?fld, ?heap) <-
    InterestingInstruction(_, ?interesting),
    StoreFldTo(?var, ?fld, ?interesting),
    VarPointsTo(_, ?heap, _, ?var).

/* Made for optimizing InterestingLoad */
LoadArrayHeapInsn(?insn, ?heap) <-
    LoadArrayIndex:Base[?insn] = ?var,
    VarPointsTo(_, ?heap, _, ?var).

/* An instruction that loads a field that an interesting instruction wrote to */
InterestingLoad(?insn) <-
    InterestingStoreHeapFld(?fld, ?heap),
    LoadFldFrom(?insn, ?var2, ?fld),
    VarPointsTo(_, ?heap, _, ?var2).

/* An instruction that loads data from an array that an interesting instruction wrote to */
InterestingLoad(?insn) <-
    InterestingInstruction(_, ?interesting),
    StoreArrayIndex:Base[?interesting] = ?var1,
    LoadArrayHeapInsn(?insn, ?heap),
    VarPointsTo(_, ?heap, _, ?var1).


/* Data dependency between the formal and actual param */
InterProceduralDependency(?ctx, ?fromInsn, ?toInsn) <-
    FormalParam[?paramIndex, ?meth] = ?formalParam,
    ActualParam[?paramIndex, ?callsite] = ?actParam,
    CallGraphEdge(_, ?callsite, ?ctx, ?meth),
    InstructionDefinesVar(?toInsn, ?actParam),
    InstructionUsesVar(?fromInsn, ?formalParam).

/* Data dependency between the return instruction and the caller */
InterProceduralDependency(?ctx, ?fromInsn, ?toInsn) <-
    ReturnNonvoid:Insn(?toInsn),
    Instruction:Method[?toInsn] = ?meth,
    CallGraphEdge(?ctx, ?fromInsn, _, ?meth).


/* Initial interesting instruction */
InterestingInstruction(?ctx, ?insn) <-
    Instruction:Method[?insn] = ?meth,
    CallGraphEdge(_, _, ?ctx, ?meth),
    InterestingInstructionInit(?insn).

/* All kinds of intra-procedural dependency */
InterestingInstruction(?ctx, ?insn)  <-
    InterestingInstruction(?ctx, ?toInsn),
    IntraProceduralDependencyOpt(?insn, ?toInsn).

/* Mark interesting loads as interesting instructions across all contexts */
InterestingInstruction(?allCtx, ?insn) <-
    InterestingLoad(?insn),
    Instruction:Method[?insn] = ?thisMeth,
    CallGraphEdge(_, _, ?allCtx, ?thisMeth).

/**
 * If an instruction is inter-procedurally dependent on an interesting instruction
 * mark that instruction as interesting in its context
 */
InterestingInstruction(?ctx, ?insn) <-
    InterestingInstruction(_, ?toInsn),
    InterProceduralDependency(?ctx, ?insn, ?toInsn).


#endif


/* Insn stores to base.fld */
StoreFldTo(?base, ?fld, ?insn) <-
    FieldInstruction:Signature[?insn] = ?fld,
    StoreInstanceField:Base[?insn] = ?base.

/* Insn loads from base.fld */
LoadFldFrom(?insn, ?base, ?fld) <-
    FieldInstruction:Signature[?insn] = ?fld,
    LoadInstanceField:Base[?insn] = ?base.

/* Var is in instruction's use set */
InstructionUsesVar(?instruction, ?var) <-
    OperAssign:From(?instruction, ?var) ;
    If:Var(?instruction, ?var) ;
    AssignLocal:From[?instruction] = ?var ;
    VirtualMethodInvocation:Base[?instruction] = ?var ;
    Switch:Key[?instruction] = ?var ;
    ActualParam[_, ?instruction] = ?var ;
    ReturnNonvoid:Var[?instruction] = ?var ;
    Throw:Var[?instruction] = ?var ;
    LoadArrayIndex:Base(?instruction, ?var) ;
    StoreArrayIndex:From(?instruction, ?var) ;
    ArrayInsnIndex(?instruction, ?var).

/* Var is in instruction's def set */
InstructionDefinesVar(?instruction, ?var) <-
    AssignInstruction:To[?instruction] = ?var ;
    LoadArrayIndex:To(?instruction, ?var) ;
    StoreArrayIndex:Base(?instruction, ?var) ;
    LoadInstanceField:To[?instruction] =  ?var ;
    LoadStaticField:To[?instruction] =  ?var ;
    AssignReturnValue[?instruction] = ?var.


/* An instruction is a CFG leaf if it ends with a throw */
CFGLeaf(?headInsn, ?method) <-
    Throw(?insn, _),
    BasicBlockHead[?insn] = ?headInsn,
    Instruction:Method[?headInsn] = ?method.

/* An instruction is a CFG leaf if it ends with a return */
CFGLeaf(?headInsn, ?method) <-
    ReturnInstruction(?insn),
    BasicBlockHead[?insn] = ?headInsn,
    Instruction:Method[?headInsn] = ?method.


/* Nothing post-dominates a CFG leaf */
DoesNotPostDominate(?postDomCandidate, ?insn) <-
    BBHeadInMethod(?postDomCandidate, ?method),
    CFGLeaf(?insn, ?method),
    ?postDomCandidate != ?insn.

/**
 * If A may come before B and C does not post-dominate B,
 * then C does not post-dominate A either, as after A the execution may go to B
 */
DoesNotPostDominate(?postDomCandidate, ?insn) <-
    DoesNotPostDominate(?postDomCandidate, ?otherInsn),
    MayPredecessorBBModuloThrow(?insn, ?otherInsn),
    ?insn != ?postDomCandidate.


/* If we can't prove A does not post-dominate B with the other rules, then A post-dominates B */
PostDominates(?dominator, ?insn) <-
    SameMethodBBHeads(?dominator, ?insn),
    !DoesNotPostDominate(?dominator, ?insn).


/* An intra procedural data dep exists when an instruction uses a var defined by another one */
IntraProceduralDataDep(?to, ?from) <-
    InstructionDefinesVar(?to, ?var),
    InstructionUsesVar(?from, ?var).


/* This block may follow an instruction, but it doesn't post dominate it */
IntraProceduralControlDep(?fromBlock, ?to) <-
    BasicBlockBegin(?fromBlock),
    MaySuccessorModuloThrow(?fromBlock, ?to),
    BasicBlockHead[?to] = ?toBlockStart,
    !PostDominates(?fromBlock, ?toBlockStart).

/**
 * This block post dominates a block that depends on an instruction
 * which this block doesn't post dominate
 */
IntraProceduralControlDep(?fromBlock, ?to) <-
    PostDominates(?fromBlock, ?interm),
    BasicBlockHead[?to] = ?toBlockStart,
    !PostDominates(?fromBlock, ?toBlockStart),
    IntraProceduralControlDep(?interm, ?to).


/* Intra procedural dependency base - data dependency */
IntraProceduralDependencyBase(?from, ?to) <-
    IntraProceduralDataDep(?to, ?from).

/* Intra procedural dependency base - control dependency */
IntraProceduralDependencyBase(?from, ?to) <-
    IntraProceduralControlDep(?fromBlock, ?to),
    BasicBlockHead[?from] = ?fromBlock.

IntraProceduralDependency(?to, ?from) <-
    IntraProceduralDependencyBase(?from, ?to).

/* Intra procedural dependency step */
IntraProceduralDependency(?to, ?from) <-
    IntraProceduralDependency(?to, ?inter),
    IntraProceduralDependencyBase(?from, ?inter).

/* Inverted for optimization */
IntraProceduralDependencyOpt(?from, ?to) <- IntraProceduralDependency(?to, ?from).
