#include "../context-insensitive/analysis.logic"
#include "../../addons/cfg-analysis/rules.logic"
#include "callgraph_deps.logic"


#ifdef CALLGRAPH_DEPS



/* A single callgraph edge */
CallGraphMethodEdge(?toMethod, ?fromMethod) <-
    Instruction:Method(?invokeInsn, ?fromMethod),
    CallGraphEdge(_, ?invokeInsn, _, ?toMethod).

/* Transitive callgraph base */
CallGraphMethodTransitive(?fromMethod, ?toMethod) <-
    CallGraphMethodEdge(?toMethod, ?fromMethod).

/* Transitive callgraph step */
CallGraphMethodTransitive(?fromMethod, ?toMethod) <-
    CallGraphMethodTransitive(?fromMethod, ?inter),
    CallGraphMethodEdge(?toMethod, ?inter).

/* Data dependency between methods due to a static field store-load */
StaticFieldMethodDataDep(?method, ?dependsOn) <-
    LoadStaticField(?field, _, ?method),
    StoreStaticField(_, ?field, ?dependsOn),
    ?method != ?dependsOn.

/* Data dependency between methods due to a static field store-load */
InstanceFieldMethodDataDep(?method, ?dependsOn) <-
    LoadHeapInstanceField(_, ?loadVar, ?field, _, ?heap),
    Var:DeclaringMethod(?loadVar, ?method),
    StoreHeapInstanceField(?field, _, ?heap, _, ?storeVar),
    Var:DeclaringMethod(?storeVar, ?dependsOn),
    ?method != ?dependsOn.

/* Data dependency between methods due to an array store-load */
HeapArrayMethodDataDep(?method, ?dependsOn) <-
    LoadHeapArrayIndex(_, ?loadVar, _, ?heap),
    Var:DeclaringMethod(?loadVar, ?method),
    StoreHeapArrayIndex(_, ?heap, _, ?storeVar),
    Var:DeclaringMethod(?storeVar, ?dependsOn),
    ?method != ?dependsOn.


/* Any of the above data dependencies */
MethodHeapDataDep(?method, ?dependsOn) <- StaticFieldMethodDataDep(?method, ?dependsOn).

MethodHeapDataDep(?method, ?dependsOn) <- InstanceFieldMethodDataDep(?method, ?dependsOn).

MethodHeapDataDep(?method, ?dependsOn) <- HeapArrayMethodDataDep(?method, ?dependsOn).


/* Method depndency either due to the transitive call graph or the above data dependencies */
MethodDependency(?toMethod, ?fromMethod) <- CallGraphMethodTransitive(?fromMethod, ?toMethod).

MethodDependency(?method, ?dependsOn) <- MethodHeapDataDep(?method, ?dependsOn).


/* The method containing the initial instruction - used to find methods that can be transitively called */
InterestingInitMethod(?initMeth) <-
    InterestingInstructionInit(_, ?insn),
    Instruction:Method[?insn] = ?initMeth.


/* Initial interesting instruction */
InterestingViaCG(?insn) <-
    InterestingInstructionInit(_, ?insn).

/* Any instruction that is intra-procedurally dependent on another interesting instruction */
InterestingViaCG(?insn) <-
    InterestingViaCG(?interesting),
    IntraProceduralDependency(?interesting, ?insn).

/**
 * Call graph dependence - mark all instructions using the params
 * of methods that can be reached through the call graph
 */
InterestingViaCG(?insn) <-
    InterestingInitMethod(?initMeth),
    MethodDependency(?meth, ?initMeth),
    FormalParam[_, ?meth] = ?formalParam,
    InstructionUsesVar(?insn, ?formalParam).

/* Field store-load inter-procedural data dependency */
InterestingViaCG(?insn) <-
    InterestingViaCG(?interesting),
    StoreFldTo(?interesting, ?var1, ?fld),
    LoadFldFrom(?insn, ?var2, ?fld),
    VarPointsTo(_, ?heap, _, ?var1),
    VarPointsTo(_, ?heap, _, ?var2).

/* Field store-load inter-procedural data dependency */
InterestingViaCG(?insn) <-
    InterestingViaCG(?interesting),
    StoreArrayIndex:Base[?interesting] = ?var1,
    LoadArrayIndex:Base[?insn] = ?var2,
    VarPointsTo(_, ?heap, _, ?var1),
    VarPointsTo(_, ?heap, _, ?var2).



#else



/* An instruction that loads a field that an interesting instruction wrote to */
InterestingLoad(?insn) <-
    InterestingInstruction(_, ?interesting),
    StoreFldTo(?interesting, ?var1, ?fld),
    LoadFldFrom(?insn, ?var2, ?fld),
    VarPointsTo(_, ?heap, _, ?var1),
    VarPointsTo(_, ?heap, _, ?var2).

/* An instruction that loads data from an array that an interesting instruction wrote to */
InterestingLoad(?insn) <-
    InterestingInstruction(_, ?interesting),
    StoreArrayIndex:Base[?interesting] = ?var1,
    LoadArrayIndex:Base[?insn] = ?var2,
    VarPointsTo(_, ?heap, _, ?var1),
    VarPointsTo(_, ?heap, _, ?var2).


/* Data dependency between the formal and actual param */
InterProceduralDependency(?callsite, ?toInsn, ?fromInsn) <-
    FormalParam[?paramIndex, ?meth] = ?formalParam,
    ActualParam[?paramIndex, ?callsite] = ?actParam,
    CallGraphEdge(_, ?callsite, _, ?meth),
    InstructionDefinesVar(?fromInsn, ?actParam),
    InstructionUsesVar(?toInsn, ?formalParam).

/* Data dependency between the return instruction and the caller */
InterProceduralDependency(?toInsn, ?toInsn, ?fromInsn) <-
    ReturnNonvoid:Insn(?fromInsn),
    Instruction:Method[?fromInsn] = ?meth,
    CallGraphEdge(_, ?toInsn, _, ?meth).


/* Initial interesting instruction */
InterestingInstruction(?callsite, ?insn) <-
    InterestingInstructionInit(?callsite, ?insn).

/* All kinds of intra-procedural dependency */
InterestingInstruction(?callsite, ?insn)  <-
    InterestingInstruction(?callsite, ?fromInsn),
    IntraProceduralDependency(?fromInsn, ?insn).

/* Mark interesting loads as interesting instructions */
InterestingInstruction(?thisMethInvocations, ?insn) <-
    InterestingLoad(?insn),
    Instruction:Method[?insn] = ?thisMeth,
    CallGraphEdge(_, ?thisMethInvocations, _, ?thisMeth).

/**
 * Mark instructions that ara data dependent inter-procedurally as interesting if they are
 * not equal to their calling instruction
 *
 * Else, use the below rule
 */
InterestingInstruction(?callsite, ?insn) <-
    ?insn != ?callsite,
    InterestingInstruction(_, ?fromInsn),
    InterProceduralDependency(?callsite, ?insn, ?fromInsn).

/**
 * If an instruction is marked interesting and has itself as the calling context,
 * we have reached a return, so we mark the caller interesting for all of its calling contexts
 */
InterestingInstruction(?thisMethInvocations, ?insn) <-
    InterestingInstruction(?insn, ?fromInsn),
    InterProceduralDependency(?insn, ?insn, ?fromInsn),
    Instruction:Method[?insn] = ?thisMeth,
    CallGraphEdge(_, ?thisMethInvocations, _, ?thisMeth).



#endif


/* Insn stores to base.fld */
StoreFldTo(?insn, ?base, ?fld) <-
    FieldInstruction:Signature[?insn] = ?fld,
    StoreInstanceField:Base[?insn] = ?base.

/* Insn loads from base.fld */
LoadFldFrom(?insn, ?base, ?fld) <-
    FieldInstruction:Signature[?insn] = ?fld,
    LoadInstanceField:Base[?insn] = ?base.

/* Var is in instruction's use set */
InstructionUsesVar(?instruction, ?var) <-
    OperAssign:From(?instruction, ?var) ;
    If:Var(?instruction, ?var) ;
    AssignLocal:From[?instruction] = ?var ;
    VirtualMethodInvocation:Base[?instruction] = ?var ;
    Switch:Key[?instruction] = ?var ;
    ActualParam[_, ?instruction] = ?var ;
    ReturnNonvoid:Var[?instruction] = ?var ;
    Throw:Var[?instruction] = ?var ;
    LoadArrayIndex:Base(?instruction, ?var) ;
    StoreArrayIndex:From(?instruction, ?var) ;
    ArrayInsnIndex(?instruction, ?var).

/* Var is in instruction's def set */
InstructionDefinesVar(?instruction, ?var) <-
    AssignInstruction:To[?instruction] = ?var ;
    LoadArrayIndex:To(?instruction, ?var) ;
    StoreArrayIndex:Base(?instruction, ?var) ;
    LoadInstanceField:To[?instruction] =  ?var ;
    LoadStaticField:To[?instruction] =  ?var ;
    AssignReturnValue[?instruction] = ?var.


/* An instruction is a CFG leaf if it ends with a throw */
CFGLeaf(?headInsn, ?method) <-
    Throw(?insn, _),
    BasicBlockHead[?insn] = ?headInsn,
    Instruction:Method[?headInsn] = ?method.

/* An instruction is a CFG leaf if it ends with a return */
CFGLeaf(?headInsn, ?method) <-
    ReturnInstruction(?insn),
    BasicBlockHead[?insn] = ?headInsn,
    Instruction:Method[?headInsn] = ?method.


/* Nothing post-dominates a CFG leaf */
DoesNotPostDominate(?postDomCandidate, ?insn) <-
    BBHeadInMethod(?postDomCandidate, ?method),
    CFGLeaf(?insn, ?method),
    ?postDomCandidate != ?insn.

/**
 * If A may come before B and C does not post-dominate B,
 * then C does not post-dominate A either, as after A the execution may go to B
 */
DoesNotPostDominate(?postDomCandidate, ?insn) <-
    DoesNotPostDominate(?postDomCandidate, ?otherInsn),
    MayPredecessorBBModuloThrow(?insn, ?otherInsn),
    ?insn != ?postDomCandidate.


/* If we can't prove A does not post-dominate B with the other rules, then A post-dominates B */
PostDominates(?dominator, ?insn) <-
    SameMethodBBHeads(?dominator, ?insn),
    !DoesNotPostDominate(?dominator, ?insn).


/* An intra procedural data dep exists when an instruction uses a var defined by another one */
IntraProceduralDataDep(?from, ?to) <-
    InstructionDefinesVar(?from, ?var),
    InstructionUsesVar(?to, ?var).


/* This block may follow an instruction, but it doesn't post dominate it */
IntraProceduralControlDep(?fromBlock, ?to) <-
    BasicBlockBegin(?fromBlock),
    MaySuccessorModuloThrow(?fromBlock, ?to),
    BasicBlockHead[?to] = ?toBlockStart,
    !PostDominates(?fromBlock, ?toBlockStart).

/**
 * This block post dominates a block that depends on an instruction
 * which this block doesn't post dominate
 */
IntraProceduralControlDep(?fromBlock, ?to) <-
    PostDominates(?fromBlock, ?interm),
    BasicBlockHead[?to] = ?toBlockStart,
    !PostDominates(?fromBlock, ?toBlockStart),
    IntraProceduralControlDep(?interm, ?to).


/* Intra procedural dependency base - data dependency */
IntraProceduralDependencyBase(?to, ?from) <-
    IntraProceduralDataDep(?from, ?to).

/* Intra procedural dependency base - control dependency */
IntraProceduralDependencyBase(?to, ?from) <-
    IntraProceduralControlDep(?toBlock, ?from),
    BasicBlockHead[?to] = ?toBlock.

IntraProceduralDependency(?from, ?to) <-
    IntraProceduralDependencyBase(?to, ?from).

/* Intra procedural dependency step */
IntraProceduralDependency(?from, ?to) <-
    IntraProceduralDependency(?from, ?inter),
    IntraProceduralDependencyBase(?to, ?inter).

