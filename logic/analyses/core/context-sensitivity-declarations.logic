#include "core-declarations.logic"

/**
 * Generic declarations for context-sensitive pointer analysis.
 */
Context(?ctx) ->.
lang:entity(`Context).
lang:physical:storageModel[`Context]="ScalableSparse".
lang:physical:capacity[`Context] = 8388608.

HContext(?hctx) ->.
lang:entity(`HContext).
lang:physical:storageModel[`HContext]="ScalableSparse".
lang:physical:capacity[`HContext] = 8388608.

ImmutableContext[]  = ?ctx  -> Context(?ctx).
ImmutableHContext[] = ?hctx -> HContext(?hctx).


// Special objects are just artificial ones that we use to find
// where the result of a reflective call can flow to. We don't want
// to track them through the heap.
SpecialObject(?heap) -> HeapAllocation(?heap).


VarPointsTo(?hctx, ?heap, ?ctx, ?var) ->
  HContext(?hctx), HeapAllocation(?heap), Context(?ctx), Var(?var).

InstanceFieldPointsTo(?hctx, ?heap, ?sig, ?basehctx, ?baseheap) ->
  HContext(?hctx), HeapAllocation(?heap),
  FieldSignature(?sig),
  HContext(?basehctx), HeapAllocation(?baseheap).

StaticFieldPointsTo(?hctx, ?heap, ?sig) ->
  FieldSignature(?sig),
  HContext(?hctx), HeapAllocation(?heap).

// array-element insensitive
ArrayIndexPointsTo(?hctx, ?heap, ?basehctx, ?baseheap) ->
  HContext(?basehctx), HeapAllocation(?baseheap),
  HContext(?hctx), HeapAllocation(?heap).

Assign(?type, ?toCtx, ?to, ?fromCtx, ?from) ->
  Type(?type),
  Context(?toCtx), Var(?to),
  Context(?fromCtx), Var(?from).

/**
 * Call graph
 */
CallGraphEdge(?callerCtx, ?invocation, ?calleeCtx, ?method) ->
  Context(?callerCtx), CallGraphEdgeSource(?invocation),
  Context(?calleeCtx), MethodSignature(?method).

/**
 * Reachable
 */
Reachable(?method) ->
  MethodSignature(?method).

ReachableContext(?ctx, ?method) ->
  Context(?ctx), MethodSignature(?method).

OptLoadInstanceField(?to, ?signature, ?base) ->
  Var(?base),
  FieldSignature(?signature),
  Var(?to).

OptLoadStaticField(?ctx, ?to, ?signature) ->
  FieldSignature(?signature),
  Context(?ctx), Var(?to).

OptStoreStaticField(?signature, ?from) ->
  Var(?from),
  FieldSignature(?signature).

OptStoreInstanceField(?from, ?signature, ?base) ->
  Var(?from),
  Var(?base),
  FieldSignature(?signature).

/*
ReachableSpecialMethodInvocation(?invocation, ?base) ->
  MethodInvocation(?invocation),
  Var(?base).

ReachableVirtualMethodInvocation(?invocation, ?base) ->
  MethodInvocation(?invocation),
  Var(?base).
*/

OptLoadArrayIndex(?to, ?base) ->
  Var(?base),
  Var(?to).

OptStoreArrayIndex(?from, ?base) ->
  Var(?from),
  Var(?base).

/**
 * Optimizations
 */

LoadHeapInstanceField(?ctx, ?to, ?sig, ?basehctx, ?baseheap) ->
  HContext(?basehctx), HeapAllocation(?baseheap),
  FieldSignature(?sig),
  Context(?ctx), Var(?to).

StoreHeapInstanceField(?sig, ?basehctx, ?baseheap, ?ctx, ?from) ->
  Context(?ctx), Var(?from),
  FieldSignature(?sig),
  HContext(?basehctx), HeapAllocation(?baseheap).

LoadHeapArrayIndex(?ctx, ?to, ?basehctx, ?baseheap) ->
  Context(?ctx), Var(?to),
  HContext(?basehctx), HeapAllocation(?baseheap).

StoreHeapArrayIndex(?basehctx, ?baseheap, ?ctx, ?from) ->
  HContext(?basehctx), HeapAllocation(?baseheap),
  Context(?ctx), Var(?from).

AssignNormalHeapAllocation(?heap, ?var, ?inmethod) ->
  HeapAllocation(?heap), Var(?var), MethodSignature(?inmethod).

AssignAuxiliaryHeapAllocation(?heap, ?var, ?inmethod) ->
  HeapAllocation(?heap), Var(?var), MethodSignature(?inmethod).

AssignContextInsensitiveHeapAllocation(?heap, ?var, ?inmethod) ->
  HeapAllocation(?heap), Var(?var), MethodSignature(?inmethod).

/**
 * Special heap abstractions.
 */
SystemThreadGroup(?hctx, ?heap) ->
  HContext(?hctx), HeapAllocation(?heap).

MainThreadGroup(?hctx, ?heap) ->
  HContext(?hctx), HeapAllocation(?heap).

MainThread(?hctx, ?heap) ->
  HContext(?hctx), HeapAllocation(?heap).


/**
 * Filter predicate for refinement-based/adaptive analyses
 */

SiteToRefine(?invocation) -> 
  CallGraphEdgeSource(?invocation).

TempSiteToRefine(?invocation) -> 
  CallGraphEdgeSource(?invocation).

ObjectToRefine(?heap) -> 
  HeapAllocation(?heap).

TempObjectToRefine(?heap) -> 
  HeapAllocation(?heap).

TaintedHeapAllocation(?heap) -> HeapAllocation(?heap).

// Is the SiteToRefine the real list of objects needing
// refinement or its negation?
NegativeSiteFilter(?v) -> string(?v).
TempNegativeSiteFilter(?v) -> string(?v).
// I could also declare a constant: NegativeSiteFilter() ->. But this is not
// exportable due to an apparent bug. Also, I tried boolean instead of string,
// but this also fails during import 
// ("cannot convert string 'boolean' to type '[].[boolean]')

// Is the ObjectToRefine the real list of objects needing
// refinement or its negation?
NegativeObjectFilter(?v) -> string(?v) .
TempNegativeObjectFilter(?v) -> string(?v).
