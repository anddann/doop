#include "../context-insensitive/analysis.logic"
#include "../../addons/cfg-analysis/rules.logic"


CallGraphMethodEdge(?toMethod, ?fromMethod) <-
    Instruction:Method(?invokeInsn, ?fromMethod),
    CallGraphEdge(_, ?invokeInsn, _, ?toMethod).

CallGraphMethodTransitive(?fromMethod, ?toMethod) <-
    CallGraphMethodEdge(?toMethod, ?fromMethod).

CallGraphMethodTransitive(?fromMethod, ?toMethod) <-
    CallGraphMethodTransitive(?fromMethod, ?inter),
    CallGraphMethodEdge(?toMethod, ?inter).



StaticFieldMethodDataDep(?method, ?dependsOn) <-
    LoadStaticField(?field, _, ?method),
    StoreStaticField(_, ?field, ?dependsOn),
    ?method != ?dependsOn.

InstanceFieldMethodDataDep(?method, ?dependsOn) <-
    LoadHeapInstanceField(_, ?loadVar, ?field, _, ?heap),
    Var:DeclaringMethod(?loadVar, ?method),
    StoreHeapInstanceField(?field, _, ?heap, _, ?storeVar),
    Var:DeclaringMethod(?storeVar, ?dependsOn),
    ?method != ?dependsOn.

HeapArrayMethodDataDep(?method, ?dependsOn) <-
    LoadHeapArrayIndex(_, ?loadVar, _, ?heap),
    Var:DeclaringMethod(?loadVar, ?method),
    StoreHeapArrayIndex(_, ?heap, _, ?storeVar),
    Var:DeclaringMethod(?storeVar, ?dependsOn),
    ?method != ?dependsOn.


MethodHeapDataDep(?method, ?dependsOn) <- StaticFieldMethodDataDep(?method, ?dependsOn).

MethodHeapDataDep(?method, ?dependsOn) <- InstanceFieldMethodDataDep(?method, ?dependsOn).

MethodHeapDataDep(?method, ?dependsOn) <- HeapArrayMethodDataDep(?method, ?dependsOn).



MethodDependency(?toMethod, ?fromMethod) <- CallGraphMethodTransitive(?fromMethod, ?toMethod).

MethodDependency(?method, ?dependsOn) <- MethodHeapDataDep(?method, ?dependsOn).


InstructionUsesVar(?instruction, ?var) <-
    OperAssign:From(?instruction, ?var).

InstructionUsesVar(?instruction, ?var) <-
    If:Var(?instruction, ?var).

InstructionUsesVar(?instruction, ?var) <-
    AssignLocal:From[?instruction] = ?var.

InstructionUsesVar(?instruction, ?var) <-
    VirtualMethodInvocation:Base[?instruction] = ?var.

InstructionUsesVar(?instruction, ?var) <-
    Switch:Key[?instruction] = ?var.

InstructionUsesVar(?instruction, ?var) <-
    ActualParam[_, ?instruction] = ?var.

InstructionUsesVar(?instruction, ?var) <-
    ReturnNonvoid:Var[?instruction] = ?var.

InstructionUsesVar(?instruction, ?var) <-
    Throw:Var[?instruction] = ?var.

InstructionUsesVar(?instruction, ?var) <-
    LoadArrayIndex:Base(?instruction, ?var).

InstructionUsesVar(?instruction, ?var) <-
    StoreArrayIndex:From(?instruction, ?var).

// TODO: should add support for AssignHeapAllocation and AssignReturnValue?
// doesn't seem to cover all cases?
InstructionDefinesVar(?instruction, ?var) <-
    AssignInstruction:To[?instruction] = ?var.

InstructionDefinesVar(?instruction, ?var) <-
    LoadArrayIndex:To(?instruction, ?var).

InstructionDefinesVar(?instruction, ?var) <-
    StoreArrayIndex:Base(?instruction, ?var).

InstructionDefinesVar(?instruction, ?var) <-
    LoadInstanceField:To[?instruction] =  ?var.

InstructionDefinesVar(?instruction, ?var) <-
    LoadStaticField:To[?instruction] =  ?var.

InstructionDefinesVar(?instruction, ?var) <-
    AssignReturnValue[?instruction] = ?var.


PostDominates(?dominator, ?insn) <-
    SameMethodBBHeads(?dominator, ?insn),
    !DoesNotPostDominate(?dominator, ?insn).


CFGLeaf(?headInsn, ?method) <-
    Throw(?insn, _),
    BasicBlockHead[?insn] = ?headInsn,
    Instruction:Method[?headInsn] = ?method.

CFGLeaf(?headInsn, ?method) <-
    ReturnInstruction(?insn),
    BasicBlockHead[?insn] = ?headInsn,
    Instruction:Method[?headInsn] = ?method.


DoesNotPostDominate(?postDomCandidate, ?insn) <-
    BBHeadInMethod(?postDomCandidate, ?method),
    CFGLeaf(?insn, ?method),
    ?postDomCandidate != ?insn.

DoesNotPostDominate(?postDomCandidate, ?insn) <-
    DoesNotPostDominate(?postDomCandidate, ?otherInsn),
    MayPredecessorBBModuloThrow(?insn, ?otherInsn),
    ?insn != ?postDomCandidate.


IntraProceduralDataDep(?from, ?to) <-
    InstructionDefinesVar(?from, ?var),
    InstructionUsesVar(?to, ?var).


/**
 * This block may follow an instruction, but it doesn't post dominate it
 */

IntraProceduralControlDep(?fromBlock, ?to) <-
    BasicBlockBegin(?fromBlock),
    MaySuccessorModuloThrow(?fromBlock, ?to),
    BasicBlockHead[?to] = ?toBlockStart,
    !PostDominates(?fromBlock, ?toBlockStart).

/**
 * This block post dominates a block that depends on an instruction
 * which this block doesn't post dominate
 */

IntraProceduralControlDep(?fromBlock, ?to) <-
    PostDominates(?fromBlock, ?interm),
    BasicBlockHead[?to] = ?toBlockStart,
    !PostDominates(?fromBlock, ?toBlockStart),
    IntraProceduralControlDep(?interm, ?to).


IntraProceduralDependencyBase(?to, ?from) <-
    IntraProceduralDataDep(?from, ?to).

IntraProceduralDependencyBase(?to, ?from) <-
    IntraProceduralControlDep(?fromBlock, ?to),
    BasicBlockHead[?from] = ?fromBlock.

/**
 * Transitive closure
 */
IntraProceduralDependency(?from, ?to) <-
    IntraProceduralDependencyBase(?to, ?from).

IntraProceduralDependency(?from, ?to) <-
    IntraProceduralDependency(?from, ?inter),
    IntraProceduralDependencyBase(?to, ?inter).


InterProceduralDependency(?fromInsn, ?toInsn, ?callsite) <-
    FormalParam[?paramIndex, ?meth] = ?formalParam,
    ActualParam[?paramIndex, ?callsite] = ?actParam,
    MethodInvocation:Signature[?callsite] = ?meth,
    InstructionDefinesVar(?fromInsn, ?actParam),
    InstructionUsesVar(?toInsn, ?formalParam).

InterProceduralDependency(?fromInsn, ?toInsn, ?toInsn) <-
    ReturnNonvoid:Insn(?fromInsn),
    Instruction:Method[?fromInsn] = ?meth,
    MethodInvocation:Signature[?toInsn] = ?meth.
