/*************************************************************
 * We use a distinct heap abstraction for every java.lang.Class, i.e., for
 * every class type that appears in the bytecode, for example '<class
 * java.lang.String>'. The predicate ReifiedClass is used to look up the heap
 * abstraction for a given type.
 *
 * Objects created by newInstance invocations are represented by a generated
 * heap allocation, a combination of the invocation-site of newInstance and the
 * type of the allocated object.
 *************************************************************/

+ReifiedClass[?type] = ?classHeap,
+HeapAllocation:Type[?classHeap] = ?javaLangClass <-
  ReferenceType(?type),
  Type:Value(?type:?typeStr),
  ?classHeap = "<class " + ?typeStr + ">",
  Type:Value(?javaLangClass:"java.lang.Class").

/**
 * Heap allocations for reified constructors (java.lang.reflect.Constructor)
 */
+ReifiedConstructor[?signature] = ?heap,
+Instruction:Value(?heap:?heapStr),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type <-
  Method:SimpleName[?signature] = "<init>",
  Method:Value(?signature:?signatureStr),
  ?heapStr = "<reified constructor " + ?signatureStr + ">",
  Type:Value(?type:"java.lang.reflect.Constructor").

/**
 * Heap allocations for reified methods (java.lang.reflect.Method)
 */
+ReifiedMethod[?signature] = ?heap,
+Instruction:Value(?heap:?heapStr),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type <-
  Method:SimpleName[?signature] = ?simplename,
  ?simplename != "<init>", ?simplename != "<clinit>",
  Method:Value(?signature:?signatureStr),
  ?heapStr = "<reified method " + ?signatureStr + ">",
  Type:Value(?type:"java.lang.reflect.Method").

/**
 * Heap allocations for reified fields (java.lang.reflect.Field)
 */
+ReifiedField[?fld] = ?heap,
+Instruction:Value(?heap:?heapStr),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type <-
  Field:Value(?fld:?signature),
  ?heapStr = "<reified field " + ?signature + ">",
  Type:Value(?type:"java.lang.reflect.Field").
