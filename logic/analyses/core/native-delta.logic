/**********************************************************************************
 * Simulation of native code by code generation.
 *
 * Note that some other natives are simulated by logic.
 **********************************************************************************/

/**
 * The ugly: macro abstractions
 *
 * This should really be generated from Jimple, but that's currently
 * somewhat complicated.
 */

#define PlusAssignLocal(strFrom, strTo, strMethod) \
  +AssignLocal(?from, ?to, ?method) <- \
    Var:Value(?from:strFrom), \
    Var:Value(?to:strTo), \
    Method:Value(?method:strMethod)

#define PlusStoreStaticField(method, local, field) \
  +StoreStaticField(?l, ?sig, ?m) <- \
    Method:Value(?m:method), \
    Var:Value(?l:local), \
    Field:Value(?sig:field)

#define SimulateNativeAllocation(strMethod, strHeap, strConstructor) \
  +AssignHeapAllocation(?heap, ?return, ?method) \
    <- \
      Method:Value(?method:strMethod), \
      ReturnVar@previous(?return, ?method), \
      HeapAllocationValue(?heap, strHeap). \
  \
  +SpecialMethodInvocation:Base[?invocation] = ?return, \
  +Instruction:Method[?invocation] = ?method, \
  +MethodInvocation:Signature[?invocation] = ?constructor, \
  PlusSpecialMethodInvocation(?invocation, ?strInvocation), \
  +Instruction:Index[?invocation] = ?index \
    <- \
      Method:Value(?method:strMethod), \
      ReturnVar@previous(?return, ?method), \
      ?strInvocation = strMethod + "/native " + strConstructor, \
      Method:Value(?constructor:strConstructor), \
      ?index = 1

#define SimulateNativeArrayAllocation(strMethod, strArray, strElement, strElementType) \
  +AssignHeapAllocation(?heap, ?return, ?method) \
    <- \
      Method:Value(?method:strMethod), \
      ReturnVar@previous(?return, ?method), \
      HeapAllocationValue(?heap, strArray). \
  \
  +Var:Value(?var), \
  +Var:Value(?var:?strVar), \
  +Var:Type[?var] = ?type, \
  +Var:DeclaringMethod(?var, ?method), \
  +AssignHeapAllocation(?heap, ?var, ?method), \
  +StoreArrayIndex(?var, ?base, ?method) \
    <- \
      Method:Value(?method:strMethod), \
      ReturnVar@previous(?base, ?method), \
      ?strVar = strMethod + "/@native-array-element", \
      Type:fqn(?type:strElementType), \
      HeapAllocationValue(?heap, strElement)

#define SimulateNativeStringArrayAllocation(strMethod, strArray, strElement, strElementType) \
  +AssignHeapAllocation(?heap, ?return, ?method) \
    <- \
      Method:Value(?method:strMethod), \
      ReturnVar@previous(?return, ?method), \
      HeapAllocationValue(?heap, strArray). \
  \
  +Var(?var), \
  +Var:Value(?var:?strVar), \
  +Var:Type[?var] = ?type, \
  +Var:DeclaringMethod(?var, ?method), \
  +AssignHeapAllocation(?heap, ?var, ?method), \
  +StoreArrayIndex(?var, ?base, ?method) \
    <- \
      Method:Value(?method:strMethod), \
      ReturnVar@previous(?base, ?method), \
      ?strVar = strMethod + "/@native-array-element", \
      Type:fqn(?type:strElementType), \
      HeapAllocationValue(?heap, strElement)

#define SimulateNativeStaticToVirtual(strMethod, strVirtual) \
  PlusVirtualMethodInvocation(?invocation, ?strInvocation), \
  +VirtualMethodInvocation(?invocation, ?signature, ?inmethod), \
  +VirtualMethodInvocation:Base[?invocation] = ?base, \
  +Instruction:Method[?invocation] = ?inmethod, \
  +MethodInvocation:Signature[?invocation] = ?signature, \
  +Instruction:Index[?invocation] = ?index \
    <- \
      Method:Value(?inmethod:strMethod), \
      FormalParam@previous[0, ?inmethod] = ?base, \
      ?strInvocation = strMethod + "/native " + strVirtual, \
      Method:Value(?signature:strVirtual), \
      ?index = 1.\
  \
  PlusMethodInvocation(?invocation, ?strInvocation), \
  +AssignReturnValue[?invocation] = ?return \
    <- \
      Method:Value(?inmethod:strMethod), \
      ReturnVar@previous(?return, ?inmethod), \
      ?strInvocation = strMethod + "/native " + strVirtual


/**********************************************************************************
 *
 * java.lang.Object
 *
 **********************************************************************************/

/**
 * <java.lang.Object: java.lang.Object clone()>
 *
 * TODO could throw CloneNotSupportedException
 *
 * TODO should check if the object is Cloneable.
 *
 * TODO should return a clone of the heap allocation (not
 *      identity). The behaviour implemented here is based on Soot.
 */
PlusAssignLocal(
  "java.lang.Object.clone/@this",
  "java.lang.Object.clone/@native-return",
  "<java.lang.Object: java.lang.Object clone()>").

/**********************************************************************************
 *
 * java.lang.System
 *
 ***************************************************/

/**
 * <java.lang.System: void setIn0(java.io.InputStream)>
 */
PlusStoreStaticField(
  "<java.lang.System: void setIn0(java.io.InputStream)>",
  "java.lang.System.setIn0/@param0",
  "<java.lang.System: java.io.InputStream in>").

/**
 * <java.lang.System: void setOut0(java.io.PrintStream)>
 */
PlusStoreStaticField(
  "<java.lang.System: void setOut0(java.io.PrintStream)>",
  "java.lang.System.setOut0/@param0",
  "<java.lang.System: java.io.PrintStream out>").

/**
 * <java.lang.System: void setErr0(java.io.PrintStream)>
 */
PlusStoreStaticField(
  "<java.lang.System: void setErr0(java.io.PrintStream)>",
  "java.lang.System.setErr0/@param0",
  "<java.lang.System: java.io.PrintStream err>").

/**
 * <java.lang.System: void arraycopy(java.lang.Object,int,java.lang.Object,int,int)>
 */
PlusVar(?tmp, ?inmethod, ?tmpStr, ?tmpType),
+LoadArrayIndex(?src, ?tmp, ?inmethod),
+StoreArrayIndex(?tmp, ?dest, ?inmethod)
    <-
      Method:Value(?arraycopy:"<java.lang.System: void arraycopy(java.lang.Object,int,java.lang.Object,int,int)>"),
      StaticMethodInvocation(?invocation, ?arraycopy, ?inmethod),
      ActualParam@previous[0, ?invocation] = ?src,
      ActualParam@previous[2, ?invocation] = ?dest,
      MethodInvocationValue(?invocation, ?strInvocation),
      ?tmpStr =  ?strInvocation + "/@tmp-arraycopy",
      Type:fqn(?tmpType:"java.lang.Object").

/**********************************************************************************
 *
 * java.io.FileSystem
 *
 **********************************************************************************/

PlusHeapAllocation(?alloc, "java.io.FileSystem.getFileSystem/new java.io.UnixFileSystem", "java.io.UnixFileSystem").
PlusHeapAllocation(?alloc, "java.io.UnixFileSystem.list/new java.lang.String[]", "java.lang.String[]").
PlusHeapAllocation(?alloc, "java.io.UnixFileSystem.list/new java.lang.String", "java.lang.String").

SimulateNativeAllocation(
  "<java.io.FileSystem: java.io.FileSystem getFileSystem()>",
  "java.io.FileSystem.getFileSystem/new java.io.UnixFileSystem",
  "<java.io.UnixFileSystem: void <init>()>").

SimulateNativeStringArrayAllocation(
  "<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>",
  "java.io.UnixFileSystem.list/new java.lang.String[]",
  "java.io.UnixFileSystem.list/new java.lang.String",
  "java.lang.String").

/**********************************************************************************
 *
 * java.lang.ref.Finalizer
 *
 **********************************************************************************/

/**
 * Indirect invocations of finalize methods from java.lang.ref.Finalizer.
 *
 * Object.finalize is a protected method, so it cannot be directly
 * invoked. Finalizer uses an indirection via native code to
 * circumvent this. This rule implements this indirection.
 */
SimulateNativeStaticToVirtual(
  "<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>",
  "<java.lang.Object: void finalize()>").

/**********************************************************************************
 *
 * java.security.AccessController
 *
 **********************************************************************************/

/**
 * The run methods of privileged actions are invoked through the
 * AccessController.doPrivileged method. This introduces an
 * indirection via native code that needs to be simulated in a pointer
 * analysis.
 *
 * Call from an invocation of doPrivileged to an implementation of the
 * PrivilegedAction.run method that will be indirectly invoked.
 *
 * The first parameter of a doPrivileged invocation (a
 * PrivilegedAction) is assigned to the 'this' variable of 'run()'
 * method invocation.
 *
 * The return variable of the 'run()' method of a privileged action is
 * assigned to the return result of the doPrivileged method
 * invocation.
 *
 * TODO for PrivilegedExceptionAction, catch exceptions and wrap them in a PriviligedActionException.
 */
SimulateNativeStaticToVirtual(
  "<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>",
  "<java.security.PrivilegedAction: java.lang.Object run()>").

SimulateNativeStaticToVirtual(
  "<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>",
  "<java.security.PrivilegedAction: java.lang.Object run()>").

SimulateNativeStaticToVirtual(
  "<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>",
  "<java.security.PrivilegedExceptionAction: java.lang.Object run()>").

SimulateNativeStaticToVirtual(
  "<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>",
  "<java.security.PrivilegedExceptionAction: java.lang.Object run()>").


/**
 * Heap object to simulate the arguments array of the main method and a single
 * heap object to simulate any external argument stored in the array.
 */
+MainMethodArgsArray(?arrayHeap),
+MainMethodArgHeap(?heap),
+Instruction:Value(?arrayHeap:?arrayHeapStr),
+HeapAllocation(?arrayHeap),
+HeapAllocation:Type[?arrayHeap] = "java.lang.String[]",
+Instruction:Value(?heap:?heapStr),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = "java.lang.String" <-
  ?arrayHeapStr = "<Main Method Arguments Array>",
  ?heapStr = "<Main Method Argument Heap Object>".


/**
 * Special initial system objects
 */
PlusHeapAllocation(?alloc, "<<system-thread-group>>", "java.lang.ThreadGroup").
PlusHeapAllocation(?alloc, "<<main-thread-group>>", "java.lang.ThreadGroup").
PlusHeapAllocation(?alloc, "<<main-thread>>", "java.lang.Thread").
