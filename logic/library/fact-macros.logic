/**
 * Macros that fix the lack of ref-modes on subtypes in LB
 */

/**
 * HeapAllocation cannot have a ref-mode, because it is a subtype
 * of Instruction. To more or less hide this, we define a
 * macro that uses the ref-mode (Instruction:Value) of the
 * base type and checks if it is a HeapAllocation.
 */

#define HeapAllocationValue(x,y) \
  Instruction:Value(x:y), \
  HeapAllocation(x)

#define StringConstantEntity(x,y) \
  Instruction:Value(x:y), \
  StringConstant(x)

#define PlusHeapAllocation(x,string,type) \
  +Instruction:Value(x:string), \
  +HeapAllocation(x), \
  +HeapAllocation:Type[x] = x ## Type, \
  +Type(x ## Type), \
  +Type:fqn(x ## Type:type)

#define PlusVar(x,method,string,type) \
  +Var(x), \
  +Var:Value(x:string), \
  +Var:Type[x] = type, \
  +Var:DeclaringMethod(x, method)

#define PlusType(x,string) \
  +Type(x), \
  +Type:fqn(x:string)

#define PlusStringConstant(x,string) \
  +Instruction:Value(x:string), \
  +StringConstant(x), \
  +HeapAllocation:Type[x] = x ## Type, \
  +Type(x ## Type), \
  +Type:fqn(x ## Type:"java.lang.String")

#define PlusClassConstant(x,string) \
  +Instruction:Value(x:string), \
  +ClassConstant(x), \
  +HeapAllocation:Type[x] = x ## Type, \
  +Type(x ## Type), \
  +Type:fqn(x ## Type:"java.lang.Class")

/**
 * Same for method invocations
 */

#define MethodInvocationValue(x, y) \
  Instruction:Value(x:y), \
  MethodInvocation(x)

#define PlusMethodInvocation(x,string) \
  +Instruction:Value(x:string), \
  +MethodInvocation(x)

#define PlusVirtualMethodInvocation(x,string) \
  +Instruction:Value(x:string), \
  +VirtualMethodInvocation:Insn(x)

#define PlusSpecialMethodInvocation(x,string) \
  +Instruction:Value(x:string), \
  +SpecialMethodInvocation:Insn(x)

#define PlusStaticMethodInvocation(x,string) \
  +Instruction:Value(x:string), \
  +StaticMethodInvocation:Insn(x)


/*
 * Similar for class type
 */

#define ClassTypeValue(x,y) \
  Type:fqn(x:y), \
  ClassType(x)
