/**
 * For a heap allocation of an object that overrides Object.finalize, invoke
 * the method Finalizer.register to register the object for finalization. The
 * allocated object becomes the actual parameter to Finalizer.register.
 */

ObjectSupportsFinalize(?heap, ?inmethod) <-
   AssignHeapAllocation(?heap, _, ?inmethod),
   HeapAllocation:Type[?heap] = ?class,
   OverridesFinalize(?class).

RecordMacro(?callerCtx, ?heap, ?hctx),
CallGraphEdge(?callerCtx, ?heap, ?calleeCtx, ?register),
MergeFinalizerRegisterContextMacro(?callerCtx, ?inmethod, ?heap, ?calleeCtx),
VarPointsTo(?hctx, ?heap, ?calleeCtx, ?formal) <-
   ReachableContext(?callerCtx, ?inmethod),
   FinalizerRegisterInfo(?register, ?formal),
   ObjectSupportsFinalize(?heap, ?inmethod),
   ObjectShouldNotBeRefined(?heap).

#ifdef RecordRefinedMacro
RecordRefinedMacro(?callerCtx, ?heap, ?hctx),
CallGraphEdge(?callerCtx, ?heap, ?calleeCtx, ?register),
MergeFinalizerRegisterContextMacro(?callerCtx, ?inmethod, ?heap, ?calleeCtx),
VarPointsTo(?hctx, ?heap, ?calleeCtx, ?formal) <-
   ReachableContext(?callerCtx, ?inmethod),
   FinalizerRegisterInfo(?register, ?formal),
   ObjectSupportsFinalize(?heap, ?inmethod),
   ObjectShouldBeRefined(?heap).
#endif


FinalizerRegisterInfo(?register, ?formal) <-
   MethodSignature:Value(?register:"<java.lang.ref.Finalizer: void register(java.lang.Object)>"),
   FormalParam[0, ?register] = ?formal.

OverridesFinalize(?class) <-
   SimpleName:Value(?simplename:"finalize"),
   MethodDescriptor:Value(?descriptor:"void()"),
   MethodLookup[?simplename, ?descriptor, ?class] = ?method,
   MethodSignature:Value(?finalizeInObject:"<java.lang.Object: void finalize()>"),
   ?finalizeInObject != ?method.
