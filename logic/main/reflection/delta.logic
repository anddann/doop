/**
 * NOTE "?sig" is reserved for this macro
 */
#define VirtualMethodMacro(invocation, to, from, sigStr) \
   Method:Value(?sig:sigStr), \
   MethodInvocation:Signature[invocation] = ?sig, \
   AssignReturnValue[invocation] = to, \
   VirtualMethodInvocation:Base[invocation] = from

/**
 * We assume that the array is allocated inside the method, before being returned.
 * NOTE "?invocationStr" and "?typeStr" are reserved for this macro
 */
#define ReflectiveArrayMacro(invocation, type, arrayType, arrayHeapStr, arrayTypeStr) \
   Instruction:Value@prev(invocation:?invocationStr), \
   Type:Value(type:?typeStr), \
   ArrayType(arrayType), Type:Value(arrayType:arrayTypeStr), \
   arrayHeapStr = "<reflective "+ ?invocationStr +"/"+ ?typeStr +"/new "+ arrayTypeStr +">"

#define ReflectiveKnownArrayMacro(invocation, arrayType, arrayHeapStr, arrayTypeStr) \
   Instruction:Value@prev(invocation:?invocationStr), \
   ArrayType(arrayType), Type:Value(arrayType:arrayTypeStr), \
   arrayHeapStr = "<reflective "+ ?invocationStr +"/new "+ arrayTypeStr +">"


#include "../../commonMacros.logic"
#include "java.lang.Class-delta.logic"
#include "java.lang.reflect.Array-delta.logic"
#include "java.lang.reflect.Constructor-delta.logic"
#include "java.lang.reflect.Field-delta.logic"
#include "java.lang.reflect.Method-delta.logic"
#include "reified-delta.logic"



#ifdef REFLECTION_USE_BASED_ANALYSIS

+SpecialMissingForNameHeap[?invocation] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   (Method:Value(?forName:"<java.lang.Class: java.lang.Class forName(java.lang.String)>") ;
    Method:Value(?forName:"<java.lang.Class: java.lang.Class forName(java.lang.String,boolean,java.lang.ClassLoader)>")),
   StaticMethodInvocation@previous(?invocation, ?forName, _),
   Type:Value(?type:"java.lang.Class"),
   Instruction:Value@previous(?invocation:?strInvocation),
   ?strHeap = "<special object for missing forName values " + ?strInvocation + ">".

// Note how the return type is that of newInstance (Object), although the relation remembers the forName
// call that produced the Class on which newInstance got called.
+SpecialMissingNewInstanceHeap[?invocation] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   (Method:Value(?forName:"<java.lang.Class: java.lang.Class forName(java.lang.String)>") ;
    Method:Value(?forName:"<java.lang.Class: java.lang.Class forName(java.lang.String,boolean,java.lang.ClassLoader)>")),
   StaticMethodInvocation@previous(?invocation, ?forName, _),
   Type:Value(?type:"java.lang.Object"),
   Instruction:Value@previous(?invocation:?strInvocation),
   ?strHeap = "<special object for missing newInstance values " + ?strInvocation + ">".

// Special heap value that propagates through all constructor calls and remembers the original forName 
+SpecialMissingGetConstructorHeap[?invocation] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   (Method:Value(?forName:"<java.lang.Class: java.lang.Class forName(java.lang.String)>") ;
    Method:Value(?forName:"<java.lang.Class: java.lang.Class forName(java.lang.String,boolean,java.lang.ClassLoader)>")),
   StaticMethodInvocation@previous(?invocation, ?forName, _),
   Type:Value(?type:"java.lang.reflect.Constructor"),
   Instruction:Value@previous(?invocation:?strInvocation),
   ?strHeap = "<special object for missing get[Declared]Constructor[s] values " + ?strInvocation + ">".

// getMethods and getDeclaredMethods are handled the same in terms of detecting
// where their unknown result flows to. Note how the return type is a single Method
// and not an array. The array is always there, the special value just gets added to
// its contents to represent all unknown methods collectively.
+SpecialMissingGetMethodsHeap[?invocation] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   (Method:Value(?getMethods:"<java.lang.Class: java.lang.reflect.Method[] getDeclaredMethods()>") ;
    Method:Value(?getMethods:"<java.lang.Class: java.lang.reflect.Method[] getMethods()>")),
   MethodInvocation:Signature@previous[?invocation] = ?getMethods,
   VirtualMethodInvocation:Insn@previous(?invocation),
   Type:Value(?type:"java.lang.reflect.Method"),
   Instruction:Value@previous(?invocation:?strInvocation),
   ?strHeap = "<special object for missing get[Declared]Methods values " + ?strInvocation + ">".

+SpecialMissingInvokeHeapFromGetMethods[?invocation] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   (Method:Value(?getMethods:"<java.lang.Class: java.lang.reflect.Method[] getDeclaredMethods()>") ;
    Method:Value(?getMethods:"<java.lang.Class: java.lang.reflect.Method[] getMethods()>")),
   MethodInvocation:Signature@previous[?invocation] = ?getMethods,
   VirtualMethodInvocation:Insn@previous(?invocation),
   Type:Value(?type:"java.lang.Object"),
   Instruction:Value@previous(?invocation:?strInvocation),
   ?strHeap = "<special object for missing invoke() values " + ?strInvocation + ">".

+SpecialMissingGetMethodHeap[?invocation] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   (Method:Value(?getMethod:"<java.lang.Class: java.lang.reflect.Method getMethod(java.lang.String,java.lang.Class[])>") ;
    Method:Value(?getMethod:"<java.lang.Class: java.lang.reflect.Method getDeclaredMethod(java.lang.String,java.lang.Class[])>")),
   MethodInvocation:Signature@previous[?invocation] = ?getMethod,
   VirtualMethodInvocation:Insn@previous(?invocation),
   Type:Value(?type:"java.lang.reflect.Method"),
   Instruction:Value@previous(?invocation:?strInvocation),
   ?strHeap = "<special object for missing get[Declared]Method values " + ?strInvocation + ">".

+SpecialMissingInvokeHeapFromGetMethod[?invocation] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   (Method:Value(?getMethod:"<java.lang.Class: java.lang.reflect.Method getMethod(java.lang.String,java.lang.Class[])>") ;
    Method:Value(?getMethod:"<java.lang.Class: java.lang.reflect.Method getDeclaredMethod(java.lang.String,java.lang.Class[])>")),
   MethodInvocation:Signature@previous[?invocation] = ?getMethod,
   VirtualMethodInvocation:Insn@previous(?invocation),
   Type:Value(?type:"java.lang.Object"),
   Instruction:Value@previous(?invocation:?strInvocation),
   ?strHeap = "<special object for missing invoke() values " + ?strInvocation + ">".

// Special objects for get[Declared]Field[s]. Very similar to methods.
+SpecialMissingGetFieldsHeap[?invocation] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   (Method:Value(?getFields:"<java.lang.Class: java.lang.reflect.Field[] getDeclaredFields()>") ;
    Method:Value(?getFields:"<java.lang.Class: java.lang.reflect.Field[] getFields()>")),
   MethodInvocation:Signature@previous[?invocation] = ?getFields,
   VirtualMethodInvocation:Insn@previous(?invocation),
   Type:Value(?type:"java.lang.reflect.Field"),
   Instruction:Value@previous(?invocation:?strInvocation),
   ?strHeap = "<special object for missing get[Declared]Fields values " + ?strInvocation + ">".

+SpecialMissingGetHeapFromGetFields[?invocation] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   (Method:Value(?getFields:"<java.lang.Class: java.lang.reflect.Field[] getDeclaredFields()>") ;
    Method:Value(?getFields:"<java.lang.Class: java.lang.reflect.Field[] getFields()>")),
   MethodInvocation:Signature@previous[?invocation] = ?getFields,
   VirtualMethodInvocation:Insn@previous(?invocation),
   Type:Value(?type:"java.lang.Object"),
   Instruction:Value@previous(?invocation:?strInvocation),
   ?strHeap = "<special object for missing get() values " + ?strInvocation + ">".

+SpecialMissingGetFieldHeap[?invocation] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   (Method:Value(?getField:"<java.lang.Class: java.lang.reflect.Field getField(java.lang.String)>") ;
    Method:Value(?getField:"<java.lang.Class: java.lang.reflect.Field getDeclaredField(java.lang.String)>")),
   MethodInvocation:Signature@previous[?invocation] = ?getField,
   VirtualMethodInvocation:Insn@previous(?invocation),
   Type:Value(?type:"java.lang.reflect.Field"),
   Instruction:Value@previous(?invocation:?strInvocation),
   ?strHeap = "<special object for missing get[Declared]Field values " + ?strInvocation + ">".

+SpecialMissingGetHeapFromGetField[?invocation] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   (Method:Value(?getField:"<java.lang.Class: java.lang.reflect.Field getField(java.lang.String)>") ;
    Method:Value(?getField:"<java.lang.Class: java.lang.reflect.Field getDeclaredField(java.lang.String)>")),
   MethodInvocation:Signature@previous[?invocation] = ?getField,
   VirtualMethodInvocation:Insn@previous(?invocation),
   Type:Value(?type:"java.lang.Object"),
   Instruction:Value@previous(?invocation:?strInvocation),
   ?strHeap = "<special object for missing get() values " + ?strInvocation + ">".

#endif // REFLECTION_USE_BASED_ANALYSIS



#ifdef REFLECTION_INVENT_UNKNOWN_OBJECTS

// This is the representative of an unknown reflective object, after it has been cast. 
// Has a real type. We pre-generate for all types and casts in the universe.
+UnknownReflectiveObject[?type, ?invocation] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   AssignCast(?type, _, _, _),
   ClassType(?type),
   Type:Value@previous(?type:?strType),
   (Method:Value(?method:"<java.lang.Class: java.lang.Object newInstance()>") ;
    Method:Value(?method:"<java.lang.reflect.Constructor: java.lang.Object newInstance(java.lang.Object[])>") ;
    Method:Value(?method:"<java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>") ;
    Method:Value(?method:"<java.lang.reflect.Field: java.lang.Object get(java.lang.Object)>")),
   MethodInvocation:Signature@previous[?invocation] = ?method,
   VirtualMethodInvocation:Insn@previous(?invocation),
   Instruction:Value@previous(?invocation:?strInvocation),
   ?strHeap = "<unknown object of type " + ?strType + " returned by call " + ?strInvocation + ">".

// This is the representative of an unknown reflective object that flows from the reflection
// operation to a cast.
+MarkerReflectiveObject[?invocation] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   (Method:Value(?method:"<java.lang.Class: java.lang.Object newInstance()>") ;
    Method:Value(?method:"<java.lang.reflect.Constructor: java.lang.Object newInstance(java.lang.Object[])>") ;
    Method:Value(?method:"<java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>") ;
    Method:Value(?method:"<java.lang.reflect.Field: java.lang.Object get(java.lang.Object)>")),
   MethodInvocation:Signature@previous[?invocation] = ?method,
   VirtualMethodInvocation:Insn@previous(?invocation),
   Type:Value(?type:"java.lang.Object"),
   Instruction:Value@previous(?invocation:?strInvocation),
   ?strHeap = "<special object for missing reflective values " + ?strInvocation + ">".

#endif // REFLECTION_INVENT_UNKNOWN_OBJECTS


/**
 * Heap allocations for reified constructors (java.lang.reflect.Constructor)
 */
+ReifiedConstructor[?signature] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   Method:SimpleName[?signature] = "<init>",
   Method:Value(?signature:?strSignature),
   ?strHeap = "<reified constructor " + ?strSignature + ">",
   Type:Value(?type:"java.lang.reflect.Constructor").

/**
 * Heap allocations for reified methods (java.lang.reflect.Method).
 */
+ReifiedMethod[?signature] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   Method:SimpleName[?signature] = ?simplename,
   ?simplename != "<init>", ?simplename != "<clinit>",
   Method:Value(?signature:?strSignature),
   ?strHeap = "<reified method " + ?strSignature + ">",
   Type:Value(?type:"java.lang.reflect.Method").

/**
 * Heap allocations for reified fields (java.lang.reflect.Field).
 */
+ReifiedField[?x] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   Field:Value(?x:?signature),
   ?strHeap = "<reified field " + ?signature + ">",
   Type:Value(?type:"java.lang.reflect.Field").
