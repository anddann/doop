#include "../context-insensitive/analysis.logic"
#include "../../addons/cfg-analysis/rules.logic"


CallGraphMethodEdge(?fromMethod, ?toMethod) <-
    Instruction:Method(?invokeInsn, ?fromMethod),
    CallGraphEdge(_, ?invokeInsn, _, ?toMethod).

CallGraphMethodTransitive(?fromMethod, ?toMethod) <-
    CallGraphMethodEdge(?fromMethod, ?toMethod).

CallGraphMethodTransitive(?fromMethod, ?toMethod) <-
    CallGraphMethodTransitive(?fromMethod, ?inter),
    CallGraphMethodEdge(?inter, ?toMethod).



StaticFieldMethodDataDep(?method, ?dependsOn) <-
    LoadStaticField(?field, _, ?method),
    StoreStaticField(_, ?field, ?dependsOn),
    ?method != ?dependsOn.

InstanceFieldMethodDataDep(?method, ?dependsOn) <-
    LoadHeapInstanceField(_, ?loadVar, ?field, _, ?heap),
    Var:DeclaringMethod(?loadVar, ?method),
    StoreHeapInstanceField(?field, _, ?heap, _, ?storeVar),
    Var:DeclaringMethod(?storeVar, ?dependsOn),
    ?method != ?dependsOn.

HeapArrayMethodDataDep(?method, ?dependsOn) <-
    LoadHeapArrayIndex(_, ?loadVar, _, ?heap),
    Var:DeclaringMethod(?loadVar, ?method),
    StoreHeapArrayIndex(_, ?heap, _, ?storeVar),
    Var:DeclaringMethod(?storeVar, ?dependsOn),
    ?method != ?dependsOn.


MethodHeapDataDep(?method, ?dependsOn) <- StaticFieldMethodDataDep(?method, ?dependsOn).

MethodHeapDataDep(?method, ?dependsOn) <- InstanceFieldMethodDataDep(?method, ?dependsOn).

MethodHeapDataDep(?method, ?dependsOn) <- HeapArrayMethodDataDep(?method, ?dependsOn).



MethodDependency(?toMethod, ?fromMethod) <- CallGraphMethodTransitive(?fromMethod, ?toMethod).

MethodDependency(?method, ?dependsOn) <- MethodHeapDataDep(?method, ?dependsOn).


InstructionUsesVar(?instruction, ?var) <-
    OperAssign:From(?instruction, ?var).

InstructionUsesVar(?instruction, ?var) <-
    If:Var(?instruction, ?var).

InstructionUsesVar(?instruction, ?var) <-
    AssignLocal:From[?instruction] = ?var.

InstructionUsesVar(?instruction, ?var) <-
    VirtualMethodInvocation:Base[?instruction] = ?var.

InstructionUsesVar(?instruction, ?var) <-
    Switch:Key[?instruction] = ?var.

InstructionUsesVar(?instruction, ?var) <-
    ActualParam[_, ?instruction] = ?var.

InstructionUsesVar(?instruction, ?var) <-
    ReturnNonvoid:Var[?instruction] = ?var.

InstructionUsesVar(?instruction, ?var) <-
    Throw:Var[?instruction] = ?var.

// TODO: should add support for AssignHeapAllocation and AssignReturnValue?
// doesn't seem to cover all cases?
InstructionDefinesVar(?instruction, ?var) <-
    AssignInstruction:To[?instruction] = ?var.


PostDominates(?dominator, ?insn) <-
    SameMethodBBHeads(?dominator, ?insn),
    !DoesNotPostDominate(?dominator, ?insn).


CFGLeaf(?headInsn, ?method) <-
    Throw(?insn, _),
    BasicBlockHead[?insn] = ?headInsn,
    Instruction:Method[?headInsn] = ?method.

CFGLeaf(?headInsn, ?method) <-
    ReturnInstruction(?insn),
    BasicBlockHead[?insn] = ?headInsn,
    Instruction:Method[?headInsn] = ?method.


DoesNotPostDominate(?postDomCandidate, ?insn) <-
    BBHeadInMethod(?postDomCandidate, ?method),
    CFGLeaf(?insn, ?method),
    ?postDomCandidate != ?insn.

DoesNotPostDominate(?postDomCandidate, ?insn) <-
    DoesNotPostDominate(?postDomCandidate, ?otherInsn),
    MayPredecessorBBModuloThrow(?insn, ?otherInsn),
    ?insn != ?postDomCandidate.


IntraProceduralDataDep(?from, ?to) <-
    InstructionDefinesVar(?from, ?var),
    InstructionUsesVar(?to, ?var).


/**
 * This block may follow an instruction, but it doesn't post dominate it
 */

IntraProceduralControlDep(?fromBlock, ?to) <-
    BasicBlockBegin(?fromBlock),
    MaySuccessorModuloThrow(?fromBlock, ?to),
    BasicBlockHead[?to] = ?toBlockStart,
    !PostDominates(?fromBlock, ?toBlockStart).    
    
/**
 * This block post dominates a block that depends on an instruction
 * which this block doesn't post dominate
 */

IntraProceduralControlDep(?fromBlock, ?to) <-
    PostDominates(?fromBlock, ?interm),
    BasicBlockHead[?to] = ?toBlockStart,
    !PostDominates(?fromBlock, ?toBlockStart),
    IntraProceduralControlDep(?interm, ?to).


/*
IntraProceduralDependency(?from, ?to) <-
    IntraProceduralDataDep(?from, ?to).

IntraProceduralDependency(?from, ?to) <-
    IntraProceduralControlDep(?fromBlock, ?to),
    BasicBlockHead[?from] = ?fromBlockStart.
*/

/**
 * Transitive closure - becomes unreasonably large
 */
//IntraProceduralDependency(?from, ?to) <-
//    IntraProceduralDependency(?from, ?inter),
//    IntraProceduralDependency(?inter, ?to).

// TODO: add load/store data deps, check if control dependency on own instruction works
