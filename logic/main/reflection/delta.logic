#include "../../commonMacros.logic"

+LoadArrayIndex(?array, ?value, ?inmethod)/*,
+java:lang:reflect:Array:get(?invocation)*/ <-
  Method:Value(?sig:"<java.lang.reflect.Array: java.lang.Object get(java.lang.Object,int)>"),
  StaticMethodInvocation(?invocation, ?sig, ?inmethod),
  ActualParam@previous[0, ?invocation] = ?array,
  AssignReturnValue[?invocation] = ?value.

+StoreArrayIndex(?value, ?array, ?inmethod)/*,
+java:lang:reflect:Array:set(?invocation)*/ <-
  Method:Value(?sig:"<java.lang.reflect.Array: void set(java.lang.Object,int,java.lang.Object)>"),
  StaticMethodInvocation(?invocation, ?sig, ?inmethod),
  ActualParam@previous[0, ?invocation] = ?array,
  ActualParam@previous[2, ?invocation] = ?value.

#ifdef REFLECTION_USE_BASED_ANALYSIS

+SpecialMissingForNameHeap[?invocation] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   (Method:Value(?forName:"<java.lang.Class: java.lang.Class forName(java.lang.String)>") ;
    Method:Value(?forName:"<java.lang.Class: java.lang.Class forName(java.lang.String,boolean,java.lang.ClassLoader)>")),
   StaticMethodInvocation@previous(?invocation, ?forName, _),
   Type:Value(?type:"java.lang.Class"),
   Instruction:Value@previous(?invocation:?strInvocation),
   ?strHeap = "<special object for missing forName values " + ?strInvocation + ">".

// Note how the return type is that of newInstance (Object), although the relation remembers the forName
// call that produced the Class on which newInstance got called.
+SpecialMissingNewInstanceHeap[?invocation] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   (Method:Value(?forName:"<java.lang.Class: java.lang.Class forName(java.lang.String)>") ;
    Method:Value(?forName:"<java.lang.Class: java.lang.Class forName(java.lang.String,boolean,java.lang.ClassLoader)>")),
   StaticMethodInvocation@previous(?invocation, ?forName, _),
   Type:Value(?type:"java.lang.Object"),
   Instruction:Value@previous(?invocation:?strInvocation),
   ?strHeap = "<special object for missing newInstance values " + ?strInvocation + ">".

// Special heap value that propagates through all constructor calls and remembers the original forName 
+SpecialMissingGetConstructorHeap[?invocation] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   (Method:Value(?forName:"<java.lang.Class: java.lang.Class forName(java.lang.String)>") ;
    Method:Value(?forName:"<java.lang.Class: java.lang.Class forName(java.lang.String,boolean,java.lang.ClassLoader)>")),
   StaticMethodInvocation@previous(?invocation, ?forName, _),
   Type:Value(?type:"java.lang.reflect.Constructor"),
   Instruction:Value@previous(?invocation:?strInvocation),
   ?strHeap = "<special object for missing get[Declared]Constructor[s] values " + ?strInvocation + ">".

// getMethods and getDeclaredMethods are handled the same in terms of detecting
// where their unknown result flows to. Note how the return type is a single Method
// and not an array. The array is always there, the special value just gets added to
// its contents to represent all unknown methods collectively.
+SpecialMissingGetMethodsHeap[?invocation] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   (Method:Value(?getMethods:"<java.lang.Class: java.lang.reflect.Method[] getDeclaredMethods()>") ;
    Method:Value(?getMethods:"<java.lang.Class: java.lang.reflect.Method[] getMethods()>")),
   MethodInvocation:Signature@previous[?invocation] = ?getMethods,
   VirtualMethodInvocation:Insn@previous(?invocation),
   Type:Value(?type:"java.lang.reflect.Method"),
   Instruction:Value@previous(?invocation:?strInvocation),
   ?strHeap = "<special object for missing get[Declared]Methods values " + ?strInvocation + ">".

+SpecialMissingInvokeHeapFromGetMethods[?invocation] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   (Method:Value(?getMethods:"<java.lang.Class: java.lang.reflect.Method[] getDeclaredMethods()>") ;
    Method:Value(?getMethods:"<java.lang.Class: java.lang.reflect.Method[] getMethods()>")),
   MethodInvocation:Signature@previous[?invocation] = ?getMethods,
   VirtualMethodInvocation:Insn@previous(?invocation),
   Type:Value(?type:"java.lang.Object"),
   Instruction:Value@previous(?invocation:?strInvocation),
   ?strHeap = "<special object for missing invoke() values " + ?strInvocation + ">".

+SpecialMissingGetMethodHeap[?invocation] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   (Method:Value(?getMethod:"<java.lang.Class: java.lang.reflect.Method getMethod(java.lang.String,java.lang.Class[])>") ;
    Method:Value(?getMethod:"<java.lang.Class: java.lang.reflect.Method getDeclaredMethod(java.lang.String,java.lang.Class[])>")),
   MethodInvocation:Signature@previous[?invocation] = ?getMethod,
   VirtualMethodInvocation:Insn@previous(?invocation),
   Type:Value(?type:"java.lang.reflect.Method"),
   Instruction:Value@previous(?invocation:?strInvocation),
   ?strHeap = "<special object for missing get[Declared]Method values " + ?strInvocation + ">".

+SpecialMissingInvokeHeapFromGetMethod[?invocation] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   (Method:Value(?getMethod:"<java.lang.Class: java.lang.reflect.Method getMethod(java.lang.String,java.lang.Class[])>") ;
    Method:Value(?getMethod:"<java.lang.Class: java.lang.reflect.Method getDeclaredMethod(java.lang.String,java.lang.Class[])>")),
   MethodInvocation:Signature@previous[?invocation] = ?getMethod,
   VirtualMethodInvocation:Insn@previous(?invocation),
   Type:Value(?type:"java.lang.Object"),
   Instruction:Value@previous(?invocation:?strInvocation),
   ?strHeap = "<special object for missing invoke() values " + ?strInvocation + ">".

// Special objects for get[Declared]Field[s]. Very similar to methods.
+SpecialMissingGetFieldsHeap[?invocation] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   (Method:Value(?getFields:"<java.lang.Class: java.lang.reflect.Field[] getDeclaredFields()>") ;
    Method:Value(?getFields:"<java.lang.Class: java.lang.reflect.Field[] getFields()>")),
   MethodInvocation:Signature@previous[?invocation] = ?getFields,
   VirtualMethodInvocation:Insn@previous(?invocation),
   Type:Value(?type:"java.lang.reflect.Field"),
   Instruction:Value@previous(?invocation:?strInvocation),
   ?strHeap = "<special object for missing get[Declared]Fields values " + ?strInvocation + ">".

+SpecialMissingGetHeapFromGetFields[?invocation] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   (Method:Value(?getFields:"<java.lang.Class: java.lang.reflect.Field[] getDeclaredFields()>") ;
    Method:Value(?getFields:"<java.lang.Class: java.lang.reflect.Field[] getFields()>")),
   MethodInvocation:Signature@previous[?invocation] = ?getFields,
   VirtualMethodInvocation:Insn@previous(?invocation),
   Type:Value(?type:"java.lang.Object"),
   Instruction:Value@previous(?invocation:?strInvocation),
   ?strHeap = "<special object for missing get() values " + ?strInvocation + ">".

+SpecialMissingGetFieldHeap[?invocation] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   (Method:Value(?getField:"<java.lang.Class: java.lang.reflect.Field getField(java.lang.String)>") ;
    Method:Value(?getField:"<java.lang.Class: java.lang.reflect.Field getDeclaredField(java.lang.String)>")),
   MethodInvocation:Signature@previous[?invocation] = ?getField,
   VirtualMethodInvocation:Insn@previous(?invocation),
   Type:Value(?type:"java.lang.reflect.Field"),
   Instruction:Value@previous(?invocation:?strInvocation),
   ?strHeap = "<special object for missing get[Declared]Field values " + ?strInvocation + ">".

+SpecialMissingGetHeapFromGetField[?invocation] = ?heap,
+Instruction:Value(?heap:?strHeap),
+HeapAllocation(?heap),
+HeapAllocation:Type[?heap] = ?type
<-
   (Method:Value(?getField:"<java.lang.Class: java.lang.reflect.Field getField(java.lang.String)>") ;
    Method:Value(?getField:"<java.lang.Class: java.lang.reflect.Field getDeclaredField(java.lang.String)>")),
   MethodInvocation:Signature@previous[?invocation] = ?getField,
   VirtualMethodInvocation:Insn@previous(?invocation),
   Type:Value(?type:"java.lang.Object"),
   Instruction:Value@previous(?invocation:?strInvocation),
   ?strHeap = "<special object for missing get() values " + ?strInvocation + ">".

#endif // REFLECTION_USE_BASED_ANALYSIS
