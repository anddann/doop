EntryPoint(?method) -> Method(?method).
AccessibleType(?type) -> Type(?type).


//preprocessor option in class DoopAnalysisFamiliy MODULENAME
//be aware supertype of null type returns everything...


ClassHasPossibleEntryPoint(?class),
PossibleEntryPoint(?method) <-
  Method:DeclaringType[?method] = ?class,
  MethodDirectAccessible(?method),
  ClassModifier("public", ?class).


ClassHasPossibleEntryPoint(?class),
PossibleEntryPoint(?method) <-
  Method:DeclaringType[?method] = ?class,
  MethodInDirectAccessible(?method),
  EntryPoint(?entryMethod),
  (
    ReturnVarMethods(?entryMethod, ?class)
         ;
    FieldsTypeMethods(?entryMethod, ?class)
  ).  


//this one takes forever and leads to overapproximation
// get the supertype methods of types in the module that are returned to the outside
ClassHasPossibleEntryPoint(?supertype),
PossibleEntryPoint(?method) <-
  SupertypeOf(?supertype, ?retType),
  !Type:null(?retType),
  ExportedByModule(?supertype),
  Method:DeclaringType[?method] = ?supertype,
  Method:Modifier("public", ?method),
  ClassModifier("public",?supertype),
  EntryPoint(?entryMethod),
  //somewhere a cut is needed, otherwise we go through the complete JDK
  //type is returned from method defined in module
  Method:DeclaringType[?entryMethod] = ?classInModule,
  ClassModuleName(MODULENAME,?classInModule),
  (
    ReturnVarMethods(?entryMethod, ?retType)
    ;
    FieldsTypeMethods(?entryMethod, ?retType)
  ).




// get the supertype methods of types in the module that are returned to the outside
ClassHasPossibleEntryPoint(?supertype),
PossibleEntryPoint(?method) <-
  SupertypeOf(?supertype, ?retType),
    !Type:null(?retType),
  ExportedByModule(?supertype),
  Method:DeclaringType[?method] = ?supertype,
  Method:Modifier("public", ?method),
  ClassModifier("public",?supertype),
  EntryPoint(?entryMethod),
  //somewhere a cut is needed, otherwise we go through the complete JDK
  //or the returned type itself is declared in the module
  ClassModuleName(MODULENAME,?retType),
  (
    ReturnVarMethods(?entryMethod, ?retType)
    ;
    FieldsTypeMethods(?entryMethod, ?retType)
  ).


//get the supertype methods of exported types of this module that do not declare methods themselves
ClassHasPossibleEntryPoint(?supertype),
PossibleEntryPoint(?method) <-
  SupertypeOf(?supertype, ?retType),
    !Type:null(?retType),
  Method:DeclaringType[?method] = ?supertype,
  ClassModifier("public", ?supertype),
  Method:Modifier("public", ?method),
  ClassModuleName(MODULENAME,?retType),
  ExportedByModule(?retType),
  ExportedByModule(?supertype).







//Methods of VarPointsTo of returnVar of entrypoints
ReturnVarMethods(?method, ?retType) <-
// get the return value of entrypoints
    ReturnVar(?var, ?method),
    VarPointsTo(_, ?value, _, ?var),
// get the types
    Value:Type[?value] = ?retType.



//get the type of the points to of public static fields
//Methods of VarPointsTo of returnVar of entrypoints
FieldsTypeMethods(?method, ?fieldType) <-
    ReturnVar(?var, ?method),
    VarPointsTo(_, ?value, _, ?var),
    Value:Type[?value] = ?retType,
    ExportedByModule(?retType),
// get the fields of the return types
    Field:DeclaringType[?field] = ?retType,
    Field:Modifier("public",?field),
    Field:Modifier("static",?field),
// get the fields PTS
   StaticFieldPointsTo(_, ?fieldValue, ?field),
// get their types
    Value:Type[?fieldValue] = ?fieldType.



// instance fields
FieldsTypeMethods(?method, ?fieldType) <-
    ReturnVar(?var, ?method),
    VarPointsTo(?hctx, ?basevalue, _, ?var),
    Value:Type[?basevalue] = ?retType,
    ExportedByModule(?retType),
// get the fields of the return types
    Field:DeclaringType[?field] = ?retType,
    Field:Modifier("public",?field),
    !Field:Modifier("static",?field),
// get the fields PTS
  InstanceFieldPointsTo(_, ?value, ?field, ?hctx, ?basevalue),
// get their types
    Value:Type[?value] = ?fieldType.



//method is directly accessible
//exported and (public or static protected)
MethodDirectAccessible(?method) <-
       Method:DeclaringType[?method] = ?class,
       ClassModuleName(MODULENAME,?class),
       ExportedByModule(?class),
      // !Method:Modifier("abstract",?method),
       (
        Method:Modifier("public", ?method);
        (
            Method:Modifier("protected",?method),
            Method:Modifier("static",?method)
        )
       ).


//method overrides/implements an exported one
MethodInDirectAccessible(?method) <-
      Method:DeclaringType[?method] = ?class,
      ClassModuleName(MODULENAME,?class),
      Method:Modifier("public", ?method),
    //check if method implements/extends overrides method in exported class
     (
       MethodInherited(?method,?class,?supertype);
       MethodInterface(?method,?class,?supertype)
     ),
     ExportedByModule(?supertype).


//MethodInDirectAccessible(?method) <-
//    SupertypeOf(?supertype, _),
   // ClassModuleName(MODULENAME,?class),
 //   ExportedByModule(?supertype),
 //   Method:DeclaringType[?method] = ?supertype,
//    Method:Modifier("public", ?method),
 //   ExportedByModule(?supertype).


//get overriden methods
MethodInherited(?meth, ?class, ?superClass) <-
   Method:DeclaringType[?meth] = ?class,
   Superclass(?class, ?superClass),
   Method:Descriptor[?meth] = ?descriptor,
   Method:SimpleName[?meth] = ?simplename,
   MethodDeclared[?simplename, ?descriptor, ?superClass] = _.



//get implemented interface methods
MethodInterface(?meth, ?class, ?interface) <-
     Method:DeclaringType[?meth] = ?class,
     Superinterface(?interface, ?class),
     Method:Descriptor[?meth] = ?descriptor,
     Method:SimpleName[?meth] = ?simplename,
     MethodDeclared[?simplename, ?descriptor, ?interface] = _.

MethodDeclared[?simplename, ?descriptor, ?type] = ?method <-
   Method:SimpleName[?method] = ?simplename,
   Method:Descriptor[?method] = ?descriptor,
   Method:DeclaringType[?method] = ?type.


//default doop rules


// Find highest level in the naming hierarchy that contains public
// methods.
ClassIsAboveOtherInNamingHierarchy(?classAbove, ?classBelow) <-
   ClassHasPossibleEntryPoint(?classAbove),
   ClassHasPossibleEntryPoint(?classBelow),
   Type:Id(?classAbove:?nameAbove), Type:Id(?classBelow:?nameBelow),
   // One's prefix before "." is a proper prefix of the other's prefix before "."
   string:substring[?nameAbove,0,LastDot[?classAbove]+1] = ?prefixAbove,
   string:substring[?nameBelow,0,LastDot[?classBelow]] = ?prefixBelow,
   string:substring[?prefixBelow,0,string:length[?prefixAbove]] = ?prefixAbove.

ClassWithTopLevelEntryPoint(?class) <-
   ClassHasPossibleEntryPoint(?class),
   !ClassIsAboveOtherInNamingHierarchy(_, ?class).

TopLevelApplicationClass(?class) <-
   ClassWithTopLevelEntryPoint(?class),
   ApplicationClass(?class).

ClassToConsider(?class) <-
   TopLevelApplicationClass(?class).

ClassToConsider(?class) <-
   !TopLevelApplicationClass(_),
   ApplicationClass(?class).

TopLevelEntryPoint(?method) <-
   PossibleEntryPoint(?method),
   Method:DeclaringType[?method] = ?class,
   ClassToConsider(?class).

// The definition we currently want as default
EntryPoint(?method) <-
   PossibleEntryPoint(?method).

