#include "../context-insensitive/declarations.logic"
#include "../../addons/cfg-analysis/declarations.logic"
#include "callgraph_deps.logic"

#ifdef CALLGRAPH_DEPS

/* Methods for callgraph-based analysis */

/**
 * Caller - callee edges
 *
 * ?toMethod    Edge to
 * ?fromMethod  Edge from
 */
CallGraphMethodEdge(?toMethod, ?fromMethod) ->
    MethodSignature(?toMethod),
    MethodSignature(?fromMethod).

/**
 * Transitive closure of the above
 *
 * ?toMethod    Edge to
 * ?fromMethod  Edge from
 */
CallGraphMethodTransitive(?fromMethod, ?toMethod) ->
    MethodSignature(?fromMethod),
    MethodSignature(?toMethod).

/**
 * Load-store dependency of a static field
 *
 * ?method      Dependant method
 * ?dependsOn   Dependence destination
 */
StaticFieldMethodDataDep(?method, ?dependsOn) ->
    MethodSignature(?method),
    MethodSignature(?dependsOn).

/**
 * Load-store dependency of an instance field
 *
 * ?method      Dependant method
 * ?dependsOn   Dependence destination
 */
InstanceFieldMethodDataDep(?method, ?dependsOn) ->
    MethodSignature(?method),
    MethodSignature(?dependsOn).

/**
 * Load-store dependency on an array
 *
 * ?method      Dependant method
 * ?dependsOn   Dependence destination
 */
HeapArrayMethodDataDep(?method, ?dependsOn) ->
    MethodSignature(?method),
    MethodSignature(?dependsOn).

/**
 * Any one of the above data dependencies
 *
 * ?method      Dependant method
 * ?dependsOn   Dependence destination
 */
MethodHeapDataDep(?method, ?dependsOn) ->
    MethodSignature(?method),
    MethodSignature(?dependsOn).

/**
 * Any data or call graph dependency
 *
 * ?method      Dependant method
 * ?dependsOn   Dependence destination
 */
MethodDependency(?method, ?dependsOn) ->
    MethodSignature(?method),
    MethodSignature(?dependsOn).

/**
 * Method that contains the initial interesting instructions
 *
 * ?initMeth    The initial instruction's method signature
 */
InterestingInitMethod(?initMeth) ->
    MethodSignature(?initMeth).

/**
 * Instructions that can possibly be influenced by the initial interesting instruction
 * Found by following the dependency transitive graph
 *
 * ?insn        Instruction that is interesting
 */
InterestingViaCG(?insn) ->
    Instruction(?insn).



#else


/* Methods for instruction-by-instruction analysis */


/**
 * Interesting instruction stores to object field
 * Provides optimization for InterestingLoad
 *
 * ?fld         The field that gets stored to
 * ?heap        The heap object containing the field
 */
InterestingStoreHeapFld(?fld, ?heap) <-
    InterestingInstruction(_, ?interesting),
    StoreFldTo(?var, ?fld, ?interesting),
    VarPointsTo(_, ?heap, _, ?var).

/**
 * Instruction loads heap
 * Provides optimization for InterestingLoad
 *
 * ?insn        The load instruction
 * ?heap        The heap object that can be loaded
 */
LoadArrayHeapInsn(?insn, ?heap) <-
    LoadArrayIndex:Base[?insn] = ?var,
    VarPointsTo(_, ?heap, _, ?var).

/**
 * Load instruction that loads interesting data
 *
 * ?insn        The interesting instruction
 */
InterestingLoad(?insn) ->
    Instruction(?insn).

/**
 * Data dependency between instructions in different methods
 * (?from depends on ?to)
 *
 * ?callsite    The calling context of the destination instruction
 * ?from        Data dependency source instruction
 * ?to          Data dependency destination instruction
 */
InterProceduralDependency(?callsite, ?from, ?to) ->
    Instruction(?callsite),
    Instruction(?from),
    Instruction(?to).


/**
 * Instructions found to be data/control dependent on the initial interesting instructions
 *
 * ?callsite    The calling context of the interesting instruction
 * ?insn        The interesting instruction
 */
InterestingInstruction(?callsite, ?insn) ->
    Instruction(?callsite),
    Instruction(?insn).



#endif


/**
 * An instruction storing to an object's field
 *
 * ?base        The object base
 * ?fld         The field being stored
 * ?insn        The store instruction
 */
StoreFldTo(?base, ?fld, ?insn) ->
    Var(?base),
    FieldSignature(?fld),
    StoreInstanceField:Insn(?insn).

/**
 * An instruction loading from an object's field
 *
 * ?insn        The load instruction
 * ?base        The object base
 * ?fld         The field being loaded
 */
LoadFldFrom(?insn, ?base, ?fld) ->
    LoadInstanceField:Insn(?insn),
    Var(?base),
    FieldSignature(?fld).


/**
 * Instruction reads from var
 *
 * ?instruction The instruction using the var
 * ?var         The var being used
 */
InstructionUsesVar(?instruction, ?var) ->
    Instruction(?instruction),
    Var(?var).


/**
 * Instruction writes to var
 *
 * ?instruction The instruction defining the var
 * ?var         The var being defined
 */
InstructionDefinesVar(?instruction, ?var) ->
    Instruction(?instruction),
    Var(?var).


/**
 * A basic block that is a leaf in its method's CFG
 *
 * ?headInsn    The leaf basic block's first instruction
 * ?method      The method containing the basic block
 */
CFGLeaf(?headInsn, ?method) ->
    Instruction(?headInsn),
    MethodSignature(?method).

/**
 * A basic block does not dominate another one
 *
 * ?dominator   The non-dominating basic block's first instruction
 * ?insn        The first instruction of the basic block not being dominated
 */
DoesNotPostDominate(?postDomCandidate, ?insn) ->
    Instruction(?postDomCandidate),
    Instruction(?insn).

/**
 * A basic block dominates another one
 *
 * ?dominator   The dominating basic block's first instruction
 * ?insn        The first instruction of basic block being dominated
 */
PostDominates(?dominator, ?insn) ->
    Instruction(?dominator),
    Instruction(?insn).


/**
 * Intra procedural data dependency, requires SSA
 * (?from depends on ?to)
 *
 * ?from        Data dependency source instruction
 * ?to          Data dependency destination instruction
 */
IntraProceduralDataDep(?from, ?to) ->
    Instruction(?from),
    Instruction(?to).


/**
 * Basic block depends on instruction
 * (all instructions in ?fromBlock basic block depend on ?to)
 *
 * ?fromBlock   Dependence source basic block's first instruction
 * ?to          Dependence destination instruction
 */
IntraProceduralControlDep(?fromBlock, ?to) ->
    Instruction(?fromBlock),
    Instruction(?to).

/**
 * Intra procedural dependency base
 * (?from depends on ?to)
 *
 * ?from        Dependence source instruction
 * ?to          Dependence destination instruction
 */
IntraProceduralDependencyBase(?from, ?to) ->
    Instruction(?from),
    Instruction(?to).

/**
 * Intra procedural dependency - transitively closed
 * (?from depends on ?to)
 *
 * ?to          Dependence destination instruction
 * ?from        Dependence source instruction
 */
IntraProceduralDependency(?to, ?from) ->
    Instruction(?to),
    Instruction(?from).

/* Same as above, inverted for optimizing some rules */
IntraProceduralDependencyOpt(?from, ?to) ->
    Instruction(?from),
    Instruction(?to).


/**
 * Instructions to perform a forward slice on
 *
 * ?insn        The instruction that will be considered tha taint source
 * ?callsite    The callsite that will be used as a calling context for the slice
 */
InterestingInstructionInit(?callsite, ?insn) ->
    Instruction(?callsite),
    Instruction(?insn).
