#include "../1-call-site-sensitive+heap/analysis.logic"
#include "../../addons/cfg-analysis/rules.logic"



/* Made for optimizing InterestingLoad */
AllCtxInterestingStoreHeapFld(?fld, ?heap) <-
    InterestingInstruction(?ctx, ?interesting),
    StoreFldTo(?var, ?fld, ?interesting),
    VarPointsTo(_, ?heap, ?ctx, ?var).

/* Made for optimizing InterestingLoad */
LoadArrayHeapInsn(?ctx, ?insn, ?heap) <-
    LoadArrayIndex:Base[?insn] = ?var,
    VarPointsTo(_, ?heap, ?ctx, ?var).

/* An instruction that loads a field that an interesting instruction wrote to */
InterestingLoad(?ctx, ?insn) <-
    AllCtxInterestingStoreHeapFld(?fld, ?heap),
    LoadFldFrom(?insn, ?var2, ?fld),
    VarPointsTo(_, ?heap, ?ctx, ?var2).

/* An instruction that loads data from an array that an interesting instruction wrote to */
InterestingLoad(?loadCtx, ?insn) <-
    InterestingInstruction(?storeCtx, ?interesting),
    StoreArrayIndex:Base[?interesting] = ?var1,
    LoadArrayHeapInsn(?loadCtx, ?insn, ?heap),
    VarPointsTo(_, ?heap, ?storeCtx, ?var1).


/* Data dependency between the formal and actual param */
CallReturnDependency(?nextCtx, ?nextInsn, ?prevCtx, ?prevInsn) <-
    FormalParam[?paramIndex, ?meth] = ?formalParam,
    ActualParam[?paramIndex, ?callsite] = ?actParam,
    CallGraphEdge(?prevCtx, ?callsite, ?nextCtx, ?meth),
    InstructionDefinesVar(?prevInsn, ?actParam),
    InstructionUsesVar(?nextInsn, ?formalParam),
    !SecureMethod(?meth).

/* Data dependency between the return instruction and the caller */
CallReturnDependency(?nextCtx, ?nextInsn, ?prevCtx, ?prevInsn) <-
    ReturnNonvoid:Insn(?prevInsn),
    Instruction:Method[?prevInsn] = ?meth,
    CallGraphEdge(?nextCtx, ?nextInsn, ?prevCtx, ?meth).


/* Initial interesting instruction */
InterestingInstruction(?ctx, ?insn) <-
    Instruction:Method[?insn] = ?meth,
    ReachableContext(?ctx, ?meth),
    InterestingInstructionInit(?insn).

/* All kinds of intra-procedural dependency */
InterestingInstruction(?ctx, ?insn)  <-
    InterestingInstruction(?ctx, ?prevInsn),
    IntraProceduralDependencyOpt(?insn, ?prevInsn),
    !SecureInstruction(?insn).

/* Mark interesting loads as interesting instructions across all contexts */
InterestingInstruction(?ctx, ?insn) <-
    InterestingLoad(?ctx, ?insn),
    !SecureMethod(Instruction:Method[?insn]),
    !SecureInstruction(?insn).

/**
 * If an instruction is inter-procedurally dependent on an interesting instruction
 * mark that instruction as interesting in its context
 */
InterestingInstruction(?ctx, ?insn) <-
    InterestingInstruction(?prevCtx, ?prevInsn),
    CallReturnDependency(?ctx, ?insn, ?prevCtx, ?prevInsn).


SecureInstruction(?insn) <- SecureInstructionInit(?insn).

SecureInstruction(?next) <-
    IntraProceduralControlDep(?nextBlock, ?prev),
    BasicBlockHead[?next] = ?nextBlock,
    SecureInstruction(?prev).


/* Insn stores to base.fld */
StoreFldTo(?base, ?fld, ?insn) <-
    FieldInstruction:Signature[?insn] = ?fld,
    StoreInstanceField:Base[?insn] = ?base.

/* Insn loads from base.fld */
LoadFldFrom(?insn, ?base, ?fld) <-
    FieldInstruction:Signature[?insn] = ?fld,
    LoadInstanceField:Base[?insn] = ?base.

/* Var is in instruction's use set */
InstructionUsesVar(?instruction, ?var) <-
    AssignLocal:From[?instruction] = ?var ;
    AssignOper:From(?instruction, ?var) ;
    AssignCast:From[?instruction] = ?var ;
    AssignInstanceOf:From[?instruction] = ?var ;
    If:Var(?instruction, ?var) ;
    VirtualMethodInvocation:Base[?instruction] = ?var ;
    Switch:Key[?instruction] = ?var ;
    ActualParam[_, ?instruction] = ?var ;
    ReturnNonvoid:Var[?instruction] = ?var ;
    Throw:Var[?instruction] = ?var ;
    LoadArrayIndex:Base[?instruction] = ?var ;
    StoreStaticField:From[?instruction] = ?var ;
    StoreInstanceField:From[?instruction] = ?var ;
    StoreArrayIndex:From[?instruction] = ?var ;
    ArrayInsnIndex[?instruction] = ?var.

/* Var is in instruction's def set */
InstructionDefinesVar(?instruction, ?var) <-
    AssignInstruction:To[?instruction] = ?var ;
    LoadArrayIndex:To(?instruction, ?var) ;
    StoreArrayIndex:Base(?instruction, ?var) ;
    LoadInstanceField:To[?instruction] =  ?var ;
    LoadStaticField:To[?instruction] =  ?var ;
    AssignReturnValue[?instruction] = ?var.


/* An instruction is a CFG leaf if it ends with a throw */
CFGLeaf(?headInsn, ?method) <-
    Throw(?insn, _),
    BasicBlockHead[?insn] = ?headInsn,
    Instruction:Method[?headInsn] = ?method.

/* An instruction is a CFG leaf if it ends with a return */
CFGLeaf(?headInsn, ?method) <-
    ReturnInstruction(?insn),
    BasicBlockHead[?insn] = ?headInsn,
    Instruction:Method[?headInsn] = ?method.


/* Nothing post-dominates a CFG leaf */
DoesNotPostDominate(?postDomCandidate, ?insn) <-
    BBHeadInMethod(?postDomCandidate, ?method),
    CFGLeaf(?insn, ?method),
    ?postDomCandidate != ?insn.

/**
 * If A may come before B and C does not post-dominate B,
 * then C does not post-dominate A either, as after A the execution may go to B.
 * This is a lot more intuitive when one thinks that "DoesNotPostDominate(a,b) =
 * exists path from b to some exit of the method, such that the path skips a".
 */
DoesNotPostDominate(?postDomCandidate, ?insn) <-
    DoesNotPostDominate(?postDomCandidate, ?otherInsn),
    MayPredecessorBBModuloThrow(?insn, ?otherInsn),
    ?insn != ?postDomCandidate.


/* If we can't prove A does not post-dominate B with the other rules, then A post-dominates B.
 * The definition is such that we always get reflexivity: PostDominates(x,x).
 */
PostDominates(?dominator, ?insn) <-
    SameMethodBBHeads(?dominator, ?insn),
    !DoesNotPostDominate(?dominator, ?insn).


/* An intra procedural data dep exists when an instruction uses a var defined by another one */
IntraProceduralDataDep(?prev, ?next) <-
    InstructionDefinesVar(?prev, ?var),
    InstructionUsesVar(?next, ?var).


/* This block may follow an instruction, but it doesn't postdominate it.
 * Invariant of this relation: ?prev is the
 * last instruction of a BB, ?nextBlock is the first of a different one.
 */
IntraProceduralControlDep(?nextBlock, ?prev) <-
    BasicBlockBegin(?nextBlock),
    MaySuccessorModuloThrow(?nextBlock, ?prev),
    BasicBlockHead[?prev] = ?prevBlockStart,
    !PostDominates(?nextBlock, ?prevBlockStart).

/**
 * This block postdominates a block that depends on an instruction
 * which this block doesn't postdominate
 */
IntraProceduralControlDep(?nextBlock, ?prev) <-
    PostDominates(?nextBlock, ?interm),
    BasicBlockHead[?prev] = ?prevBlockStart,
    !PostDominates(?nextBlock, ?prevBlockStart),
    IntraProceduralControlDep(?interm, ?prev).


/* Intra procedural dependency base - data dependency */
IntraProceduralDependencyBase(?next, ?prev) <-
    IntraProceduralDataDep(?prev, ?next).

/* Intra procedural dependency base - control dependency */
IntraProceduralDependencyBase(?next, ?prev) <-
    IntraProceduralControlDep(?nextBlock, ?prev),
    BasicBlockHead[?next] = ?nextBlock.

IntraProceduralDependency(?prev, ?next) <-
    IntraProceduralDependencyBase(?next, ?prev).

/* Intra procedural dependency step */
IntraProceduralDependency(?prev, ?next) <-
    IntraProceduralDependency(?prev, ?inter),
    IntraProceduralDependencyBase(?next, ?inter).

/* Inverted for optimization */
IntraProceduralDependencyOpt(?next, ?prev) <- IntraProceduralDependency(?prev, ?next).
